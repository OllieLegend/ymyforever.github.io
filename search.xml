<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Computer Networks and the Internet</title>
    <url>/2020/09/16/Internet/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>开始读这本神奇的书了，嗯，英文版，嗯，八百多页。在这期间不打算开新的书了，这些足够我读一段时间了。</p>
<p>Keep on moving!</p>
<p>同学说800多页这学期读不完的，每天20页还需要一个多月去读。首先呢，这本书不一定要读完，重点的是靠这本书快速入门；开了这么多书，你一定要坚持住嗷~</p>
<p>读英文真的需要心无旁骛，不然一会就不知道读的是啥了，哭哭！</p>
<a id="more"></a>
<h2 id="1-什么是Internet？"><a href="#1-什么是Internet？" class="headerlink" title="1  什么是Internet？"></a>1  什么是Internet？</h2><h3 id="1-1-Internet的组成"><a href="#1-1-Internet的组成" class="headerlink" title="1.1 Internet的组成"></a>1.1 Internet的组成</h3><p>Internet是一种计算机网络将世界上的计算装置连接起来。所有被连接起来的装置称为主机或终端系统。</p>
<p>终端系统由communication links和packet switiches组成的网络相连。</p>
<ul>
<li>communication links由许多种，有光纤、铜线等多种。不同的类型有不同的传输速度。</li>
<li>packet switch把packets传送到它们最终的目的地。在今天的Internet中，最优秀的packet switch是路由器和链路层交换机（link-layer switches）。</li>
</ul>
<p>作者给了一个<strong>非常巧妙</strong>的比喻：</p>
<p>packets就像货车，communication links就像高速路，packet switch就是交叉路口，终端系统就像建筑。</p>
<p>货车在运输网络中前行；packet在计算机网络中前行。</p>
<p>终端系统是怎么接入网络的呢？</p>
<p>终端系统通过ISPs（Internet Service Providers）接入网络，包括住宅ISP、校园ISP等。这里你又该疑惑了，什么是ISP呢？</p>
<p>ISP本身是packet switches和communication links组成的网络，ISP提供多种接入网络的方式，包括小区宽带、无线等。</p>
<p>终端系统、packet switches等其他部分运行控制信息收发的协议。在互联网中最重要的协议有TCP（Transmission Control Protocol）协议和IP（Internet Protocol）协议。</p>
<ul>
<li>IP协议：说明包的格式</li>
</ul>
<h3 id="1-2-Internet提供的服务"><a href="#1-2-Internet提供的服务" class="headerlink" title="1.2 Internet提供的服务"></a>1.2 Internet提供的服务</h3><p>Internet是向用户提供服务的基础设施。</p>
<p>这里作者又给出了一个比喻，就像在写信时要遵守规则写上收件人、住址，网络间通信时，也要遵守一定的规则。</p>
<h3 id="1-3-什么是协议（Protocol）"><a href="#1-3-什么是协议（Protocol）" class="headerlink" title="1.3 什么是协议（Protocol）"></a>1.3 什么是协议（Protocol）</h3><p>怕不怕，抽不抽象（手动狗头）</p>
<p>聪明的读者不用害怕，作者又举例子了。</p>
<p>计算机与服务器间的信息传递过程，就像人与人之间的过程一样。</p>
<p>在我们连接网页时，我们的计算机会首先发出连接请求，Web服务器接收到请求后会给出一个回应，计算机接收到许可回应后，会把想要访问的资源名称发送给服务器，Web服务器会把资源发送给计算机。</p>
<p>在这个过程中信息的交换等协议的关键定义元素。</p>
<h2 id="2-网络的边缘"><a href="#2-网络的边缘" class="headerlink" title="2. 网络的边缘"></a>2. 网络的边缘</h2><p>什么是网络的边缘？</p>
<p>网络的边缘包括上文中提到的各种终端和主机。它们在整个网络中处于边缘位置，所以称为网络的边缘。</p>
<h3 id="2-1-网络的边缘怎么连接网络？"><a href="#2-1-网络的边缘怎么连接网络？" class="headerlink" title="2.1 网络的边缘怎么连接网络？"></a>2.1 网络的边缘怎么连接网络？</h3>]]></content>
  </entry>
  <entry>
    <title>Web核心防御机制</title>
    <url>/2020/10/19/Web%E6%A0%B8%E5%BF%83%E9%98%B2%E5%BE%A1%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>又开一本新书啦~ 白帽子讲Web安全和图解HTTP已经读过啦！近期要多读好书，远离弱智小说、营销号！这本书读完就缩小研究方向嗷！冲！</p>
<h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><p>知己知彼，百战不殆。既然网络世界如此凶险，那么Web应用程序必然采取了一系列的防御机制，抵御恶意攻击。</p>
<p>Web应用程序主要采用的防御机制有如下几个核心因素：</p>
<ul>
<li>处理用户<strong>访问</strong>应用程序的数据与功能。</li>
<li>处理用户对应用程序功能的<strong>输入</strong>。</li>
<li>防范<strong>攻击者</strong>，确保应用程序在成为攻击目标时能正常运作。</li>
<li>管理应用程序，监控其行为。</li>
</ul>
<p>这是一道送分题啊！姐妹们！人都告诉你人在哪防御啦！说明啥鸭！说明这个地方重要或者比较脆弱，所以攻击就攻击这里啊！</p>
<h2 id="2-处理用户访问"><a href="#2-处理用户访问" class="headerlink" title="2. 处理用户访问"></a>2. 处理用户访问</h2><p>在处理Web应用用户访问时，使用三层相互关联的安全机制处理用户访问。如下三层：</p>
<ul>
<li>身份验证：最典型的是登陆账号、密码。为了加强这个阶段也可以基于客户端证书等。</li>
<li>会话管理：在用户身份验证后，服务器给每个用户发送标识会话的令牌，少数程序使用HTTP内置的身份验证机制完成会话管理。</li>
<li>访问控制：决定允许或拒绝用户的请求。</li>
</ul>
<p>这三个部分紧密相连，层层递进，任何一个部分存在缺陷都会让攻击者有机可乘。</p>
<h2 id="3-处理用户输入"><a href="#3-处理用户输入" class="headerlink" title="3. 处理用户输入"></a>3. 处理用户输入</h2><p>在Web应用程序中，用户的输入需求是多种多样的，对用户输入内容的限制条件也是各不相同。通常</p>
<h3 id="3-1-输入内容处理解决用户输入问题"><a href="#3-1-输入内容处理解决用户输入问题" class="headerlink" title="3.1 输入内容处理解决用户输入问题"></a>3.1 输入内容处理解决用户输入问题</h3><p>有以下几种方法处理用户输入：</p>
<ul>
<li>拒绝已知的不良输入：基于黑名单的思想，限制特定字符的输入，效率低下</li>
<li>接受已知的正常输入：基于白名单的思想，只接受与良性输入匹配的字符串，但用户体验不好。</li>
<li>净化：对用户输入的无法保证安全的字符进行删除、净化或转义。</li>
<li>安全数据处理：不确认输入是否安全，以特殊方法确保处理过程的安全。</li>
<li>语法检查：攻击者利用提交企图实现一些恶意目的。</li>
</ul>
<h3 id="3-2-边界确认解决用户输入问题"><a href="#3-2-边界确认解决用户输入问题" class="headerlink" title="3.2 边界确认解决用户输入问题"></a>3.2 边界确认解决用户输入问题</h3><img src="/2020/10/19/Web%E6%A0%B8%E5%BF%83%E9%98%B2%E5%BE%A1%E6%9C%BA%E5%88%B6/image-20201019181250809.png" class title="This is an example image">
<h2 id="4-处理攻击者"><a href="#4-处理攻击者" class="headerlink" title="4. 处理攻击者"></a>4. 处理攻击者</h2><p>为处理攻击者采取的措施一般由以下任务组成：</p>
<ul>
<li>处理错误：详细的错误信息可能为攻击者对应用程序发起进攻提供便利。</li>
<li>维护审计日志：应包含身份验证功能记录、关键交易、被阻止的访问企图、任何已知攻击字符串</li>
<li>向管理员发出警报：对应用反常、交易反常、包含已知攻击字符串的请求、普通用户无权限的数据修改</li>
<li>应对攻击：拖延时间。。。</li>
</ul>
<h2 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. 总结</h2><p>综上，Web的核心防御机制几乎是从用户访问Web页面就开始了，尤其时在用户向服务器提交内容时，最容易受到攻击，相应的，这块的防御也相对较强。同时，被攻击后的应对措施也十分重要，如何将损失降低到最小，是我们应该考虑的。</p>
]]></content>
  </entry>
  <entry>
    <title>HelloWorld!</title>
    <url>/2020/08/29/HelloWorld/</url>
    <content><![CDATA[<h2 id="A-new-world"><a href="#A-new-world" class="headerlink" title="A new world!"></a>A new world!</h2><p>哈喽！历经一个下午博客终于搭建好了，原来是那么容易的一件事情，大一的时候想的很复杂，迟迟没能动手，现在也终于有了自己的小博客啦~</p>
<p>未来灌水的文章还是会首先发在CSDN上，这里会分享一些重大的经历~已经大三了！要更努力学习！不要被些奇奇怪怪的事情干扰，奥里给！</p>
]]></content>
  </entry>
  <entry>
    <title>XSS构造技巧</title>
    <url>/2020/10/02/XSS%E6%9E%84%E9%80%A0%E6%8A%80%E5%B7%A7/</url>
    <content><![CDATA[<p>XSS的攻击力是可见一斑的，但是在现实生活中，XSS的构造技巧是复杂的。是根据网站的各种特性、结构灵活构造的。常见的XSS构造方法有以下几种（假装自己是大佬，实则在搬运书上的内容哈哈哈！</p>
<ul>
<li>利用字符编码：根据网页的编码吃掉系统的转义符等，绕过安全检查。</li>
<li>绕过长度限制：利用event、注释符绕过输入框的长度限制</li>
<li>使用\<base>标签：\<base>标签用于指定页面上相对路径标签上的hosting地址，实现XSS攻击</li>
<li>window.name妙用：摆脱同源策略的限制，实现跨域、跨页面数据传递</li>
<li>Flash XSS：用户的Flash文件可以实施脚本攻击，Flash也会产生XSS漏洞。</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>坚定</title>
    <url>/2020/09/30/%E5%9D%9A%E5%AE%9A/</url>
    <content><![CDATA[<p>陈学长说，切忌两天打鱼，三天晒网，一旦开始学习了，就要坚持下去。无论对待哪门课程，哪件事，都要坚持下去。</p>
<p>另外一点是，要敢想、敢做，选择一条路，坚定地走下去。陈学长可以考清华（深圳），那我也可以！更何况，我还有很长的准备时间。</p>
<p>现在最重要的两件事：</p>
<ul>
<li>大三课程学习</li>
<li>考研数学</li>
</ul>
<p>希望在大三上结束的时候，可以过完一轮！加油！</p>
]]></content>
  </entry>
  <entry>
    <title>XSS的防御</title>
    <url>/2020/10/02/XSS%E7%9A%84%E9%98%B2%E5%BE%A1/</url>
    <content><![CDATA[<p>由于XSS的攻击构造的复杂性，其防御技巧也是复杂的。但也是有一些万金油可以抵御大部分的XSS攻击。</p>
<ul>
<li>HttpOnly：抵御XSS后的Cookie劫持，禁止页面的JavaScript访问带有HttpOnly属性的Cookie。</li>
<li>输入检查：即格式检查，用白名单指定输入格式，</li>
<li>输出检查：使用编码或转义处理输出变量。</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>自顶向下语法分析方法</title>
    <url>/2020/10/07/%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>计算机网络测验1</title>
    <url>/2020/09/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%B5%8B%E9%AA%8C1/</url>
    <content><![CDATA[<p>今天来写一些计算机网络的测验题，看起来还是和平常的测验题很不一样的，遂打算记录在博客上。</p>
<h2 id="1-问题描述"><a href="#1-问题描述" class="headerlink" title="1. 问题描述"></a>1. 问题描述</h2><p>从源主机发送$8 \times 10^6$bit的长消息，传输过程中链路带宽为2Mbps，忽略<strong>传播</strong>、排队和处理延时。</p>
<p>数据传输过程如下:</p>
<pre class="mermaid">
graph LR
A(source) --> B(packet switch)
B --> C(packet switch)
C --> D(Destination)</pre>

<a id="more"></a>
<h3 id="1-1-问题a-1"><a href="#1-1-问题a-1" class="headerlink" title="1.1 问题a(1)"></a>1.1 问题a(1)</h3><p>考虑不分组的情况下将消息从源主机发送到目的地，请问将消息<strong>从源主机发送到第一个交换机</strong>需要多长时间？</p>
<p><strong>答：</strong>信息的大小已知，链路带宽已知，由于不考虑传播时延，因此只需考虑发送时延，其中链路带宽即数字信通所能传达的“最高数据率”。则时间为：<script type="math/tex">t=\frac{8 \times 10^6}{2 \times10^6}=4s</script></p>
<h3 id="1-2-问题a-2"><a href="#1-2-问题a-2" class="headerlink" title="1.2 问题a(2)"></a>1.2 问题a(2)</h3><p>当每个交换机都是用存储转发分组交换时，将消息从源主机发送到目标主机的总时间是多少？</p>
<p><strong>答：</strong>由问题1已知，从源主机到第一个交换机的时间为4s，则从源主机到目标主机的总时间是<script type="math/tex">4 \times 3 =12s</script>。</p>
<p>在上述基础上，假设消息被分割成800个数据包每个数据包长度为10000比特。</p>
<h3 id="1-3-问题b-1"><a href="#1-3-问题b-1" class="headerlink" title="1.3 问题b(1)"></a>1.3 问题b(1)</h3><p>将第一个包从源主机移动到第一个交换机需要多长时间？</p>
<p><strong>答：</strong><script type="math/tex">t=\frac{1 \times 10^4}{2 \times 10^6}=5ms</script></p>
<h3 id="1-4-问题b-2"><a href="#1-4-问题b-2" class="headerlink" title="1.4 问题b(2)"></a>1.4 问题b(2)</h3><p>当第一个交换机向第二个交换机发送第一个包时，第二个包从源主机向第一个交换机发送，请问在什么时间第一个交换机能够完全接收第二个数据包？</p>
<p><strong>答：</strong>由于每个链路带宽相同，不考虑传播、排队、处理时延，因此在5ms后，第一个交换机能够完全接收第二个数据包。</p>
<h3 id="1-5-问题c"><a href="#1-5-问题c" class="headerlink" title="1.5 问题c"></a>1.5 问题c</h3><p>使用消息分段时，将文件从源主机发送到目标主机需要多长时间？将结果与在(a)部分的答案进行比较并讨论。</p>
<p><strong>答：</strong>使用消息分段时，初始时，只有源主机发送包，接着，源主机和第一个交换机发送包，最后源主机、两个交换机都在发送包。在发送接近结束时，源主机、第一个交换机、第二个交换机依次停止发送。</p>
<p>因此，将文件从源主机发送到目标主机需要<script type="math/tex">t=\frac{800 \times 3-1-2-1-2}{3} \times 5 + 4 \times 5=</script> 4.01s &lt;12s </p>
<p>与上述计算出来的答案进行比较，消息分段显著降低了消息发送的总时间。另外，消息分段发送的总时间接近于未分段发送一次的时间。由于分段发送初始时、结束时所占时间极少，信息在交换机间并行发送，可看作仅由源主机直接发送至目标主机。</p>
<h3 id="1-6-问题d"><a href="#1-6-问题d" class="headerlink" title="1.6 问题d"></a>1.6 问题d</h3><p>除可以降低延迟外，使用消息分段还有什么优势?</p>
<p><strong>答：</strong>1. 由于消息分段传输，因此在消息需要更新时，可以只发送更新的部分，提高效率。</p>
<p>​        2. 由于分段之后数据短小，适合采用优先级策略，发送一些紧急数据</p>
<h3 id="1-7-问题e"><a href="#1-7-问题e" class="headerlink" title="1.7 问题e"></a>1.7 问题e</h3><p>讨论消息分段的缺点。</p>
<p>答：1. 消息分段增加了转发的次数和时延，要求结点交换机具有更强的处理能力。</p>
<ol>
<li>由于消息分段，每段要加上编号等信息，总的传输信息量增大了。</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>跨站脚本攻击</title>
    <url>/2020/09/28/%E8%B7%A8%E7%AB%99%E8%84%9A%E6%9C%AC%E6%94%BB%E5%87%BB/</url>
    <content><![CDATA[<img src="/2020/09/28/%E8%B7%A8%E7%AB%99%E8%84%9A%E6%9C%AC%E6%94%BB%E5%87%BB/first.png" class title="This is an example image">
<p>跨站脚本攻击乍一看是不是有点陌生？其实它就是我们经常听到的XSS，这一定是跨站脚本攻击的英文⑧，其实，跨站脚本攻击的英文是Cross Site Script，缩写应该为CSS，但是与层叠样式表的CSS有所雷同，因此就改为XSS！（X嘛！琦琦子说了的，无限可能！）</p>
<p>在学习XSS之前，需要明确的是，什么是跨站脚本攻击？</p>
<a id="more"></a>
<h3 id="1-1-何为跨站脚本攻击？"><a href="#1-1-何为跨站脚本攻击？" class="headerlink" title="1.1 何为跨站脚本攻击？"></a>1.1 何为跨站脚本攻击？</h3><p>XSS通常是指，黑客利用HTML注入篡改了网页，插入恶意脚本，在用户浏览网页时，控制用户浏览器的一种攻击。这样说起来还是有点抽象，其实说白了就是想尽办法篡改网页的代码，让它执行你所期待的脚本，这种脚本或是窃取用户的隐私信息（如Cookie），或是达到破坏的目的。</p>
<p>根据XSS的效果，可以将其分为以下几类：</p>
<ul>
<li>反射型XSS（非持久型XSS）：把用户输入的数据简单地反射给浏览器</li>
<li>存储型XSS（持久型XSS）：把恶意脚本保存到服务器</li>
<li>DOM Based XSS：反射型XSS的一种特殊情况，通过修改DOM节点形成的XSS。</li>
</ul>
<p>这里的反射型和存储型还都能理解，主要是这个DOM啊，这里还是请教百度老师。</p>
<blockquote>
<p>DOM即Document Object Model，是万维网联盟W3C的标准，定义了访问HTML和XML文档的标准。</p>
</blockquote>
<p>DOM大概就是一个标准，那么DOM节点是啥子呢？</p>
<blockquote>
<p>在HTML DOM标准中，HTML所有内容都是节点。包括文档节点、元素节点、属性节点等。</p>
</blockquote>
<p>那么DOM Based XSS也就是通过修改HTML中的元素，达到攻击的目的，比如闭合标签、注释标签等。</p>
<h2 id="2-XSS攻击"><a href="#2-XSS攻击" class="headerlink" title="2. XSS攻击"></a>2. XSS攻击</h2><p>实现XSS攻击的方式多种多样，大致可分为以下几类：</p>
<ul>
<li>XSS Payload</li>
<li>XSS Worm</li>
</ul>
<p>我们将分别对其展开介绍。</p>
<h3 id="2-1-XSS-Payload"><a href="#2-1-XSS-Payload" class="headerlink" title="2.1 XSS Payload"></a>2.1 XSS Payload</h3><p>XSS Payload即XSS攻击成功后，被植入浏览器的恶意脚本。而这些脚本实质上是JavaScript脚本（可见不做一个Scripts Kid还是得学会JavaScript啊！）</p>
<p>在XSS攻击成功后，Payload脚本通过多种方式控制用户的浏览器，实施破坏或窃取信息。</p>
<h4 id="2-1-1-构造GET与POST请求"><a href="#2-1-1-构造GET与POST请求" class="headerlink" title="2.1.1 构造GET与POST请求"></a>2.1.1 构造GET与POST请求</h4><p>GET与POST请求是HTTP协议中的通信方法，一个网站的应用，通过这两种请求就可以完成所有操作，但是悲伤的是，通过JavaScript就能让浏览器发送这种请求。</p>
<p>形象的来说，这种方法就是让JavaScript脚本通过发起请求模拟浏览器去执行相关操作。</p>
<h4 id="2-1-2-XSS-钓鱼"><a href="#2-1-2-XSS-钓鱼" class="headerlink" title="2.1.2 XSS+钓鱼"></a>2.1.2 XSS+钓鱼</h4><p>网络世界上的钓鱼我们都知道，就是伪造一个知名的站点，骗取用户的信息，属于一种被动的攻击方式。将XSS与钓鱼结合，利用钓鱼获得关键信息，比如密码等，利用获得的信息进行XSS攻击。</p>
<h4 id="2-1-3-识别用户浏览器"><a href="#2-1-3-识别用户浏览器" class="headerlink" title="2.1.3 识别用户浏览器"></a>2.1.3 识别用户浏览器</h4><p>识别用户的浏览器为什么那么重要呢？孙子早就说过了，知己知彼，百战不殆。通过XSS可以读取浏览器的版本信息等，达到收集信息的目的。一般较为准确的获得浏览器版本信息的方式是通过判断浏览器是否存在某些版本浏览器的特性实现的。</p>
<h4 id="2-1-4-识别用户安装的软件"><a href="#2-1-4-识别用户安装的软件" class="headerlink" title="2.1.4 识别用户安装的软件"></a>2.1.4 识别用户安装的软件</h4><p>这里其实乍一看还是很奇怪的，浏览器和软件有什么关系？？？其实某些特定的软件会在浏览器里安装特殊的控件，某些插件如flash也会暴露计算机中的硬件信息。</p>
<p><em>获得这些软硬件信息又有啥用呢？</em></p>
<p>安装的软件可能会在浏览器中造成漏洞，通过XSS获得应用安装的软件，可以实现植入木马等攻击方式。</p>
<h4 id="2-1-5-CSS-History-Hack"><a href="#2-1-5-CSS-History-Hack" class="headerlink" title="2.1.5 CSS History Hack"></a>2.1.5 CSS History Hack</h4><p>这个原理其实非常简单，而且目前已经被修复了。</p>
<p>在我们小的时候使用电脑，会发现点过链接或图标会和没点过的颜色不同，通过CSS可以获得用户是否浏览过某个页面。</p>
<h4 id="2-1-6-获取用户的真实IP地址"><a href="#2-1-6-获取用户的真实IP地址" class="headerlink" title="2.1.6 获取用户的真实IP地址"></a>2.1.6 获取用户的真实IP地址</h4><p>这种方式其实还是借助第三方软件完成的。JavaScript本身不具有提供本地IP地址的能力，但是Java有啊~ 如果客户端安装了Java环境，就可以通过接口获得客户端的IP地址。</p>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>总的来说XSS是一个寻找突破口，通过各种方式获得用户信息的攻击方法，重要的呢，还是对Web系统有足够的了解，还有一定的JavaScript基础。</p>
]]></content>
  </entry>
  <entry>
    <title>限时碎片</title>
    <url>/2020/10/04/%E9%99%90%E6%97%B6%E7%A2%8E%E7%89%87/</url>
    <content><![CDATA[<p>这是怎样的一种心情？这种孤独会持久吗？是我太敏感了吗？我觉得无所谓的事情，他们非常在意，所以群居要不断迁就，又是渴望孤独的一天，渴望自由的一天。</p>
<p>人呢，是群居动物，不断抱团取暖，又不断陷入孤独。</p>
<p>希望你心平气和，不变初心，在黯淡的岁月里，向着目标前进，加油！</p>
<p>晚安呐！明天又是奋斗的一天。啾咪。</p>
]]></content>
  </entry>
  <entry>
    <title>CTF校赛</title>
    <url>/2020/10/12/CTF%E6%A0%A1%E8%B5%9B/</url>
    <content><![CDATA[<blockquote>
<p>电计1806</p>
<p>袁梦瑶</p>
<p>201886013</p>
</blockquote>
<p>小白第一次打比赛了，真的好上头ORZ。</p>
<p>这次比赛做出了以下题目，根据题目的类型，写出题解。</p>
<a id="more"></a>
<div class="table-container">
<table>
<thead>
<tr>
<th><a href="http://10.7.20.225:4000/challenges#签到题-43">签到题</a></th>
<th>a simple check in</th>
<th>200</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="http://10.7.20.225:4000/challenges#派对邀请函-5">派对邀请函</a></td>
<td>crypto</td>
<td>50</td>
</tr>
<tr>
<td><a href="http://10.7.20.225:4000/challenges#broken webpage 2-9">broken webpage 2</a></td>
<td>web</td>
<td>50</td>
</tr>
<tr>
<td><a href="http://10.7.20.225:4000/challenges#糟糕的调音师-58">糟糕的调音师</a></td>
<td>misc</td>
<td>120</td>
</tr>
<tr>
<td><a href="http://10.7.20.225:4000/challenges#可靠的志愿时长查询网站（1）-19">可靠的志愿时长查询网站（1）</a></td>
<td>web</td>
<td>328</td>
</tr>
<tr>
<td><a href="http://10.7.20.225:4000/challenges#你的手机-60">你的手机</a></td>
<td>apk</td>
<td>50</td>
</tr>
<tr>
<td><a href="http://10.7.20.225:4000/challenges#very_easy-64">very_easy</a></td>
<td>crypto</td>
<td>50</td>
</tr>
<tr>
<td><a href="http://10.7.20.225:4000/challenges#流量告急-17">流量告急</a></td>
<td>web</td>
<td>200</td>
</tr>
<tr>
<td><a href="http://10.7.20.225:4000/challenges#偷来的代码-10">偷来的代码</a></td>
<td>misc</td>
<td>379</td>
</tr>
<tr>
<td><a href="http://10.7.20.225:4000/challenges#Guess The Flag-24">Guess The Flag</a></td>
<td>misc</td>
<td>50</td>
</tr>
<tr>
<td><a href="http://10.7.20.225:4000/challenges#秋天的第一道逆向-35">秋天的第一道逆向</a></td>
<td>reverse</td>
<td>241</td>
</tr>
<tr>
<td><a href="http://10.7.20.225:4000/challenges#白神话：悟能-11">白神话：悟能</a></td>
<td>misc</td>
<td>304</td>
</tr>
<tr>
<td><a href="http://10.7.20.225:4000/challenges#babyrop-47">babyrop</a></td>
<td>pwn</td>
<td>482</td>
</tr>
<tr>
<td><a href="http://10.7.20.225:4000/challenges#What remains of white pagoda-13">What remains of white pagoda</a></td>
<td>misc</td>
<td>267</td>
</tr>
<tr>
<td><a href="http://10.7.20.225:4000/challenges#俸俸伲 购美病-15">俸俸伲 购美病</a></td>
<td>misc</td>
<td>359</td>
</tr>
<tr>
<td><a href="http://10.7.20.225:4000/challenges#可靠的志愿时长查询网站（2）-18">可靠的志愿时长查询网站（2）</a></td>
<td>web</td>
<td>500</td>
</tr>
<tr>
<td><a href="http://10.7.20.225:4000/challenges#零卡攻略网-31">零卡攻略网</a></td>
<td>misc</td>
<td>349</td>
</tr>
<tr>
<td><a href="http://10.7.20.225:4000/challenges#问卷题-68">问卷题</a></td>
<td>问卷题</td>
<td>50</td>
</tr>
<tr>
<td><a href="http://10.7.20.225:4000/challenges#very_easy2-66">very_easy2</a></td>
<td>crypto</td>
<td>338</td>
</tr>
<tr>
<td><a href="http://10.7.20.225:4000/challenges#归来的蟒蛇-36">归来的蟒蛇</a></td>
<td>reverse</td>
<td>470</td>
</tr>
<tr>
<td><a href="http://10.7.20.225:4000/challenges#解救djinni-7">解救djinni</a></td>
<td>crypto</td>
<td>470</td>
</tr>
</tbody>
</table>
</div>
<h2 id="crypto"><a href="#crypto" class="headerlink" title="crypto"></a>crypto</h2><h3 id="1-派对邀请函"><a href="#1-派对邀请函" class="headerlink" title="1. 派对邀请函"></a>1. 派对邀请函</h3><p>题目描述如下：</p>
<blockquote>
<p>欢迎各位参加派对，派对的邀请码是:ajkbky{hzsbprz_kp_rf_odmkf}<br>PS:邀请函的信封上面写着affine</p>
</blockquote>
<p>这里很明确给出了加密方法是affine（仿射变换），根据flag的格式，ajkbky对应着dutctf。</p>
<p>仿射变换的加密方式即$y=(ax+b)mod26$，$x$即将字母a~z按照0~25进行映射得到的。根据已知的信息c、d经加密后变为了1、0，可以列出如下式子：<script type="math/tex">(2a+b)mod26=1</script> <script type="math/tex">(3a+b)mod26=0</script></p>
<p>根据这两个式子大胆猜测$3a+b-2a-b=25$，即$a=25$。则再大胆猜测$b=3$。在<a href="http://ctf.ssleye.com/affine.html">在线工具</a>中小心求证：</p>
<img src="/2020/10/12/CTF%E6%A0%A1%E8%B5%9B/image-20201012161320110.png" class title="This is an example image">
<p>运气爆棚！</p>
<h3 id="2-very-easy"><a href="#2-very-easy" class="headerlink" title="2. very_easy"></a>2. very_easy</h3><p>题目给出了如下的01序列：</p>
<blockquote>
<p>11001000111010101110100011000110111010001100110011110110110101001110101011100110111010001011111011100100110010101101100011000010111100001111101</p>
</blockquote>
<p>简单看了一下，143列，不太美妙，再观察一下序列头部1100100对应着ASCII码中的d！这已经很说明问题了，说明这题是根据二进制序列得到ASCII码对应的字符，但是这个143列怎么划分呢？因此在序列最初位补0，将序列扩充为144列，正好可以分成32个8位二进制数。</p>
<p>利用在线转换工具：</p>
<p><img src="/2020/10/12/CTF%E6%A0%A1%E8%B5%9B/forblog\blog\source\_posts\CTF校赛\image-20201012164520341.png" alt="image-20201012164520341"></p>
<h3 id="3-very-easy2"><a href="#3-very-easy2" class="headerlink" title="3. very_easy2"></a>3. very_easy2</h3><p>这么easy的嘛？题目描述：</p>
<blockquote>
<p>flag为：dutctf{xxxx}（xxxx为4位可见字符）</p>
<p>flag的32位MD5为：2F63E0BE261A8BBC6D04F67A6420BE73</p>
</blockquote>
<p>首先，能提取到的信息是flag是dutctf{四个字符}，加密方式为MD5。心头一喜，这不又一个在线工具就能解决的嘛，冲冲冲。结果！在线工具全都不能用……，全都解码失败，嘤嘤嘤。换一种思路来看，flag中只有四位是不确定的，因此可以进行穷举，即将所有的可能flag均进行一次MD5编码，若与题目所给相同，则为正确的flag。</p>
<p>说干就干，Python代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line">dict=[<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;2&#x27;</span>,<span class="string">&#x27;3&#x27;</span>,<span class="string">&#x27;4&#x27;</span>,<span class="string">&#x27;5&#x27;</span>,<span class="string">&#x27;6&#x27;</span>,<span class="string">&#x27;7&#x27;</span>,<span class="string">&#x27;8&#x27;</span>,<span class="string">&#x27;9&#x27;</span>,<span class="string">&#x27;0&#x27;</span>,<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;d&#x27;</span>,<span class="string">&#x27;e&#x27;</span>,<span class="string">&#x27;f&#x27;</span>,<span class="string">&#x27;g&#x27;</span>,<span class="string">&#x27;h&#x27;</span>,<span class="string">&#x27;i&#x27;</span>,<span class="string">&#x27;j&#x27;</span>,<span class="string">&#x27;k&#x27;</span>,<span class="string">&#x27;l&#x27;</span>,<span class="string">&#x27;m&#x27;</span>,<span class="string">&#x27;n&#x27;</span>,<span class="string">&#x27;o&#x27;</span>,<span class="string">&#x27;p&#x27;</span>,<span class="string">&#x27;q&#x27;</span>,<span class="string">&#x27;r&#x27;</span>,<span class="string">&#x27;s&#x27;</span>,<span class="string">&#x27;t&#x27;</span>,<span class="string">&#x27;u&#x27;</span>,<span class="string">&#x27;v&#x27;</span>,<span class="string">&#x27;w&#x27;</span>,<span class="string">&#x27;x&#x27;</span>,<span class="string">&#x27;y&#x27;</span>,<span class="string">&#x27;z&#x27;</span>,<span class="string">&#x27;A&#x27;</span>,<span class="string">&#x27;B&#x27;</span>,<span class="string">&#x27;C&#x27;</span>,<span class="string">&#x27;D&#x27;</span>,<span class="string">&#x27;E&#x27;</span>,<span class="string">&#x27;F&#x27;</span>,<span class="string">&#x27;G&#x27;</span>,<span class="string">&#x27;H&#x27;</span>,<span class="string">&#x27;I&#x27;</span>,<span class="string">&#x27;J&#x27;</span>,<span class="string">&#x27;K&#x27;</span>,<span class="string">&#x27;L&#x27;</span>,<span class="string">&#x27;M&#x27;</span>,<span class="string">&#x27;N&#x27;</span>,<span class="string">&#x27;O&#x27;</span>,<span class="string">&#x27;P&#x27;</span>,<span class="string">&#x27;Q&#x27;</span>,<span class="string">&#x27;R&#x27;</span>,<span class="string">&#x27;S&#x27;</span>,<span class="string">&#x27;T&#x27;</span>,<span class="string">&#x27;U&#x27;</span>,<span class="string">&#x27;V&#x27;</span>,<span class="string">&#x27;W&#x27;</span>,<span class="string">&#x27;X&#x27;</span>,<span class="string">&#x27;Y&#x27;</span>,<span class="string">&#x27;Z&#x27;</span>];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">jm_md5</span>(<span class="params">password</span>):</span></span><br><span class="line">    m = hashlib.md5()  <span class="comment"># 构建MD5对象</span></span><br><span class="line">    m.update(password.encode(encoding=<span class="string">&#x27;utf-8&#x27;</span>)) <span class="comment">#设置编码格式 并将字符串添加到MD5对象中</span></span><br><span class="line">    password_md5 = m.hexdigest()  <span class="comment"># hexdigest()将加密字符串 生成十六进制数据字符串值</span></span><br><span class="line">    <span class="keyword">return</span> password, password_md5</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">62</span>):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">62</span>):</span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> range(<span class="number">62</span>):</span><br><span class="line">            <span class="keyword">for</span> m <span class="keyword">in</span> range(<span class="number">62</span>):</span><br><span class="line">                g=jm_md5(<span class="string">&#x27;dutctf&#123;&#x27;</span>+dict[i]+dict[j]+dict[k]+dict[m]+<span class="string">&#x27;&#125;&#x27;</span>);</span><br><span class="line">                <span class="keyword">if</span>(g[<span class="number">1</span>]==<span class="string">&#x27;2f63e0be261a8bbc6d04f67a6420be73&#x27;</span>):</span><br><span class="line">                    print(g);</span><br><span class="line">                    exit(<span class="number">0</span>);</span><br><span class="line">                    </span><br></pre></td></tr></table></figure>
<p>运行结果如下图所示：</p>
<p><img src="/2020/10/12/CTF%E6%A0%A1%E8%B5%9B/forblog\blog\source\_posts\CTF校赛\image-20201012165531028.png" alt="image-20201012165531028"></p>
<h3 id="4-解救djinni"><a href="#4-解救djinni" class="headerlink" title="4. 解救djinni"></a>4. 解救djinni</h3><p>这一题啊，这一题是三因子RSA。主要信息如下：</p>
<blockquote>
<p>n=28116501373069407529213390531934071240414724809734554101278337447648500850443874609634759871069124858471130508433374448577838830472420657794929950007704638114247135033643982446865019513802727631106264690573292907167703752264974438544477447411763513030827927646266015229042229047040884286226890097583263897118280598364992512298956815392685402922761695703536745127506370152135062261686045823207730047163547093865636626595424846315894348566041716817943762598947184414510650358649685893036636541625188322614290875362015491795655295050491512522830808195017431009672814060376303672362050873644513053562819138851207809579117<br>c=19866489767594156836541562259623272128065662749348680891720498852620196212982394122215521298026657621891937349917437004361046980750115732963572660841065965187469747890695962127007998382594056214490464853349221<br>e=3</p>
</blockquote>
<p>首先网上没找到解题工具，就去了解一下原理，发现问题的关键好像要求解n的质因子，这就陷入了死循环，n的位数太大了！并没有一个求解质因子的有效方法。后来在<a href="RSA攻击手法及相应例题解析 - 合粉的文章 - 知乎 https://zhuanlan.zhihu.com/p/46487673">网上冲浪</a>的时候发现这道题的关键在于e=3！3太小了，这是一种典型的低加密指数攻击。可以用Python求解：</p>
<p>代码如下:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> gmpy2,binascii,libnum,time</span><br><span class="line">n=<span class="number">28116501373069407529213390531934071240414724809734554101278337447648500850443874609634759871069124858471130508433374448577838830472420657794929950007704638114247135033643982446865019513802727631106264690573292907167703752264974438544477447411763513030827927646266015229042229047040884286226890097583263897118280598364992512298956815392685402922761695703536745127506370152135062261686045823207730047163547093865636626595424846315894348566041716817943762598947184414510650358649685893036636541625188322614290875362015491795655295050491512522830808195017431009672814060376303672362050873644513053562819138851207809579117</span></span><br><span class="line">c=<span class="number">19866489767594156836541562259623272128065662749348680891720498852620196212982394122215521298026657621891937349917437004361046980750115732963572660841065965187469747890695962127007998382594056214490464853349221</span></span><br><span class="line">e=<span class="number">3</span></span><br><span class="line">i=<span class="number">0</span>;</span><br><span class="line">print(time.asctime())</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">200000000</span>):</span><br><span class="line">    <span class="keyword">if</span> gmpy2.iroot(c+n*i,e)[<span class="number">1</span>]==<span class="number">1</span>:</span><br><span class="line">        res=gmpy2.iroot(c+n*i,e)[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">print</span> (i,res)</span><br><span class="line">        <span class="keyword">print</span> (libnum.n2s(res))</span><br><span class="line">        <span class="keyword">print</span> (time.asctime())</span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure>
<p>这里运行起来还是有点问题的，但是不影响解题。运行结果如下：</p>
<p><img src="/2020/10/12/CTF%E6%A0%A1%E8%B5%9B/forblog\blog\source\_posts\CTF校赛\image-20201012170709725.png" alt="image-20201012170709725"></p>
<p>这里已经得到了目标的十进制序列，但是这明显和flag的格式不同鸭！这时候考虑它是不是用了奇奇怪怪的编码，将10进制转为16进制，再转换为文本：</p>
<p><img src="/2020/10/12/CTF%E6%A0%A1%E8%B5%9B/forblog\blog\source\_posts\CTF校赛\image-20201012171122310.png" alt="image-20201012171122310"></p>
<h2 id="web"><a href="#web" class="headerlink" title="web"></a>web</h2><h3 id="1-broken-webpage-2"><a href="#1-broken-webpage-2" class="headerlink" title="1. broken webpage 2"></a>1. broken webpage 2</h3><p>这一题首先根据网页中的提示去点按钮获得flag，发现按钮在不断移动，因此企图修改源码使得button可点击，在搜寻了一圈后，发现script标签里的move函数呗编码加密了，为了搞懂button的修改方法，在<a href="https://tool.lu/js/">在线工具</a>里对该部分代码进行解码：</p>
<p><img src="/2020/10/12/CTF%E6%A0%A1%E8%B5%9B/forblog\blog\source\_posts\CTF校赛\image-20201013104828416.png" alt="image-20201013104828416"></p>
<h3 id="2-流量告急"><a href="#2-流量告急" class="headerlink" title="2.流量告急"></a>2.流量告急</h3><p>这道题刚开始绕了挺久。。。先是想着修改前端代码、甚至burpsuite抓包修改购买金额，但是最终无果呜呜呜，后来才发现原来是负溢出问题。</p>
<p>只需要一直在购买框里买负金额的流量即可。直到超出负数的极限。</p>
<p><img src="/2020/10/12/CTF%E6%A0%A1%E8%B5%9B/forblog\blog\source\_posts\CTF校赛\image-20201013110733859.png" alt="image-20201013110733859"></p>
<h3 id="3-可靠的志愿时长查询网站（1）"><a href="#3-可靠的志愿时长查询网站（1）" class="headerlink" title="3. 可靠的志愿时长查询网站（1）"></a>3. 可靠的志愿时长查询网站（1）</h3><p>这道题其实首先没往SQL注入上想，刚开始觉得是弱密码爆破，结果爆了个寂寞，之后才尝试用SQL注入解题。直接搜索了SQL注入的语句，绕过登陆验证的方法主要是用or 1=1使得条件成立，并用#注释后面的语句。</p>
<p><img src="/2020/10/12/CTF%E6%A0%A1%E8%B5%9B/forblog\blog\source\_posts\CTF校赛\image-20201013130500835.png" alt="image-20201013130500835"></p>
<p>小小尝试一下，成功绕过登陆检验。拿到flag</p>
<p><img src="/2020/10/12/CTF%E6%A0%A1%E8%B5%9B/forblog\blog\source\_posts\CTF校赛\image-20201013130539255.png" alt="image-20201013130539255"></p>
<h3 id="4-可靠的志愿时长查询网站-2"><a href="#4-可靠的志愿时长查询网站-2" class="headerlink" title="4. 可靠的志愿时长查询网站(2)"></a>4. 可靠的志愿时长查询网站(2)</h3><p>这一题就有意思了，第一次跟着网上的教程摸索出来的。成就感还是有的哈哈~</p>
<p><img src="/2020/10/12/CTF%E6%A0%A1%E8%B5%9B/forblog\blog\source\_posts\CTF校赛\image-20201013131348811.png" alt="image-20201013131348811"></p>
<p>经过测试可以得知，用大写字符可以绕过敏感词检验，并且为数字型注入漏洞。</p>
<p>因此可以在这个注入点进行一些探索。</p>
<p>首先确定表中有多少个字段：</p>
<p>由查询信息可得，至少有8个字段，从8向上递增，当测试到12时，显示返回信息错误，因此字段个数为11。</p>
<p><img src="/2020/10/12/CTF%E6%A0%A1%E8%B5%9B/forblog\blog\source\_posts\CTF校赛\image-20201013131739285.png" alt="image-20201013131739285"></p>
<p>确定字段个数之后，就可根据Union联合查询爆破数据库、表名。冲冲冲！</p>
<p>使用如下语句爆破：</p>
<ul>
<li><p>获得数据库名: number=1 UNION SELECT database(),database(),database(),database(),database(),database(),database(),database(),database(),database(),database()#</p>
<p>获得数据库名：vol_time_2</p>
</li>
<li><p>获得表名：number=1 UNION SELECT TABLE_NAME,TABLE_NAME,TABLE_NAME,TABLE_NAME,TABLE_NAME,TABLE_NAME,TABLE_SCHEMA,TABLE_SCHEMA,TABLE_SCHEMA,TABLE_SCHEMA,TABLE_SCHEMA FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_SCHEMA= ‘vol_time_2’#</p>
<p>获得表flag和vt_bak。</p>
</li>
</ul>
<p>获得了一张名为flag的表，事情没那么简单，flag肯定在这个表里，大胆猜测flag表里还有个flag字段。</p>
<p><img src="/2020/10/12/CTF%E6%A0%A1%E8%B5%9B/forblog\blog\source\_posts\CTF校赛\image-20201013202541120.png" alt="image-20201013202541120"></p>
<p>猜对啦！</p>
<p>总结一下就是数据库里有个flag表，flag表里有个flag字段，flag字段里存储着flag!</p>
<h2 id="PWN"><a href="#PWN" class="headerlink" title="PWN"></a>PWN</h2><h3 id="1-babyrop"><a href="#1-babyrop" class="headerlink" title="1. babyrop"></a>1. babyrop</h3><p>题目中已经说明了，是栈溢出。这里需要安装pwn包，但是由于我的python版本为3.xx，并且懒得用虚拟机，这里就根据<a href="https://www.anquanke.com/post/id/210394">教程</a>安装了winpwn。</p>
<p>之后的关键就是payload的构造，这里采用了这个<a href="https://www.jianshu.com/p/d4db898762e6">基本模板</a>。栈溢出的原理是向栈中写入数据覆盖栈中其他的数据，从而影响程序的运行。原理参考了<a href="https://blog.csdn.net/sinat_31054897/article/details/82223889?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-3.channel_param&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-3.channel_param">这篇文章</a>。</p>
<p>将babyrop送入IDA反编译，可以查看其函数：</p>
<p>阅读main函数可以发现栈溢出漏洞：</p>
<p><img src="/2020/10/12/CTF%E6%A0%A1%E8%B5%9B/forblog\blog\source\_posts\CTF校赛\image-20201014092312541.png" alt="image-20201014092312541"></p>
<p>发现后门函数：</p>
<p><img src="/2020/10/12/CTF%E6%A0%A1%E8%B5%9B/forblog\blog\source\_posts\CTF校赛\image-20201014092553612.png" alt="image-20201014092553612"></p>
<p>其地址为：</p>
<p><img src="/2020/10/12/CTF%E6%A0%A1%E8%B5%9B/forblog\blog\source\_posts\CTF校赛\image-20201014093358805.png" alt="image-20201014093358805"></p>
<p>因此可以利用栈溢出控制返回地址。</p>
<p>根据栈可得，把栈填满需要偏移量为24。</p>
<p><img src="/2020/10/12/CTF%E6%A0%A1%E8%B5%9B/forblog\blog\source\_posts\CTF校赛\image-20201014093133022.png" alt="image-20201014093133022"></p>
<p>构造payload如下：payload=’A’*24 + p64(0x00000000004006B6)</p>
<p>在命令行中运行文件，得到flag</p>
<p><img src="/2020/10/12/CTF%E6%A0%A1%E8%B5%9B/forblog\blog\source\_posts\CTF校赛\image-20201014093621652.png" alt="image-20201014093621652"></p>
<h2 id="reverse"><a href="#reverse" class="headerlink" title="reverse"></a>reverse</h2><h3 id="1-秋天的第一道逆向"><a href="#1-秋天的第一道逆向" class="headerlink" title="1. 秋天的第一道逆向"></a>1. 秋天的第一道逆向</h3><p>直接txt打开查找关键词dutctf。</p>
<p><img src="/2020/10/12/CTF%E6%A0%A1%E8%B5%9B/forblog\blog\source\_posts\CTF校赛\image-20201013202956375.png" alt="image-20201013202956375"></p>
<h3 id="2-归来的蟒蛇"><a href="#2-归来的蟒蛇" class="headerlink" title="2. 归来的蟒蛇"></a>2. 归来的蟒蛇</h3><p>这道题首先下载下来的是pyc文件，这是python文件编译的一个过程文件，反编译之后可以得到原始的python代码，反编译之后的python代码如下（加上了代码分析过程中的一些注释）所示：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#! /usr/bin/env python 3.7 (3394)</span></span><br><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"><span class="comment"># Compiled at: 1969-12-31 18:00:00</span></span><br><span class="line"><span class="comment">#Powered by BugScaner</span></span><br><span class="line"><span class="comment">#http://tools.bugscaner.com/</span></span><br><span class="line"><span class="comment">#如果觉得不错,请分享给你朋友使用吧!</span></span><br><span class="line">aaa = [<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;D&#x27;</span>, <span class="string">&#x27;E&#x27;</span>, <span class="string">&#x27;F&#x27;</span>, <span class="string">&#x27;G&#x27;</span>, <span class="string">&#x27;H&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;I&#x27;</span>, <span class="string">&#x27;J&#x27;</span>, <span class="string">&#x27;K&#x27;</span>, <span class="string">&#x27;L&#x27;</span>, <span class="string">&#x27;M&#x27;</span>, <span class="string">&#x27;N&#x27;</span>, <span class="string">&#x27;O&#x27;</span>, <span class="string">&#x27;P&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;Q&#x27;</span>, <span class="string">&#x27;R&#x27;</span>, <span class="string">&#x27;S&#x27;</span>, <span class="string">&#x27;T&#x27;</span>, <span class="string">&#x27;U&#x27;</span>, <span class="string">&#x27;V&#x27;</span>, <span class="string">&#x27;W&#x27;</span>, <span class="string">&#x27;X&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;Y&#x27;</span>, <span class="string">&#x27;Z&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;f&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;g&#x27;</span>, <span class="string">&#x27;h&#x27;</span>, <span class="string">&#x27;i&#x27;</span>, <span class="string">&#x27;j&#x27;</span>, <span class="string">&#x27;k&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;m&#x27;</span>, <span class="string">&#x27;n&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;o&#x27;</span>, <span class="string">&#x27;p&#x27;</span>, <span class="string">&#x27;q&#x27;</span>, <span class="string">&#x27;r&#x27;</span>, <span class="string">&#x27;s&#x27;</span>, <span class="string">&#x27;t&#x27;</span>, <span class="string">&#x27;u&#x27;</span>, <span class="string">&#x27;v&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;w&#x27;</span>, <span class="string">&#x27;x&#x27;</span>, <span class="string">&#x27;y&#x27;</span>, <span class="string">&#x27;z&#x27;</span>, <span class="string">&#x27;9&#x27;</span>, <span class="string">&#x27;8&#x27;</span>, <span class="string">&#x27;7&#x27;</span>, <span class="string">&#x27;6&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;5&#x27;</span>, <span class="string">&#x27;4&#x27;</span>, <span class="string">&#x27;3&#x27;</span>, <span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;0&#x27;</span>, <span class="string">&#x27;+&#x27;</span>, <span class="string">&#x27;/&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">##长度为27...30 </span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bbb</span>(<span class="params">string</span>):</span></span><br><span class="line">    string = string.encode()</span><br><span class="line">    ret = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    bytes_bin = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">for</span> b <span class="keyword">in</span> string:</span><br><span class="line">        bytes_bin = bytes_bin + <span class="string">&#x27;&#123;:0&gt;8&#125;&#x27;</span>.format(str(bin(b))[<span class="number">2</span>:])</span><br><span class="line">        <span class="comment">#print(bytes_bin);</span></span><br><span class="line"></span><br><span class="line">    three_byte_zise = len(bytes_bin) // <span class="number">24</span> <span class="comment">##24的倍数</span></span><br><span class="line">    remain_size = len(bytes_bin) % <span class="number">24</span>  <span class="comment">##24的余数</span></span><br><span class="line">    three_byte_group = bytes_bin[:<span class="number">24</span> * three_byte_zise] <span class="comment">##[0:0..24..48]</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> three_byte_group:  </span><br><span class="line">        byte_group = three_byte_group[<span class="number">0</span>:<span class="number">24</span>]</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> (<span class="number">0</span>, <span class="number">6</span>, <span class="number">12</span>, <span class="number">18</span>):</span><br><span class="line">            ret = ret + aaa[int(byte_group[j:j + <span class="number">6</span>], <span class="number">2</span>)]<span class="comment">##结果映射a,循环一次，结果+4,将二进制转换为10进制</span></span><br><span class="line"></span><br><span class="line">        three_byte_group = three_byte_group[<span class="number">24</span>:]<span class="comment">##向后取24</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> remain_size:<span class="comment">##</span></span><br><span class="line">        remain_part = bytes_bin[<span class="number">24</span> * three_byte_zise:] + <span class="string">&#x27;0&#x27;</span> * (<span class="number">24</span> - remain_size)<span class="comment">##剩余部分填成24位</span></span><br><span class="line">        print(remain_part)</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> (<span class="number">0</span>, <span class="number">6</span>, <span class="number">12</span>, <span class="number">18</span>):</span><br><span class="line">            ret = ret + aaa[int(remain_part[j:j + <span class="number">6</span>], <span class="number">2</span>)]<span class="comment">##结果+4</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ret[<span class="number">-2</span>] == <span class="string">&#x27;A&#x27;</span>:</span><br><span class="line">        ret = ret[<span class="number">0</span>:<span class="number">-2</span>] + <span class="string">&#x27;==&#x27;</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">if</span> ret[<span class="number">-1</span>] == <span class="string">&#x27;A&#x27;</span>:</span><br><span class="line">            ret = ret[:<span class="number">-1</span>] + <span class="string">&#x27;=&#x27;</span></span><br><span class="line">    <span class="keyword">return</span> ret</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    print(<span class="string">&#x27;input:&#x27;</span>)</span><br><span class="line">    m = input()</span><br><span class="line">    <span class="keyword">if</span> bbb(m) == <span class="string">&#x27;ZHV9Y6Rme6B4dGhvbl0pc80jb78taW4nX7JhY7t0&#x27;</span>:</span><br><span class="line">        print(<span class="string">&#x27;bingo&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>分析上述代码，可以得到该程序把输入经bbb函数加密，正确的bbb即flag加密后应与’ZHV9Y6Rme6B4dGhvbl0pc80jb78taW4nX7JhY7t0’相同。因此需要详细解读上述加密代码。</p>
<p>bbb函数首先输入的字符串中的每个字符转化为8位的二进制数，每三个字节在密文中增加4个字符，若剩余的字节数不足三个或总字节数小于3，则在密文中增加4个字符。</p>
<p>题目中所给字符有40位，因此可能的情况有多种，<strong>首先考虑最简单的情况</strong>，即字节数正好为3的整数倍，即30个字节。</p>
<p>之后考虑密文增加的方法，根据ret = ret + aaa[int(byte_group[j:j + 6], 2)]，可以看到原始字节中的6位二进制数转化为一个十进制数，并取aaa[该十进制数]。</p>
<p>那么我们可以根据密文中的字符，逐个对照aaa找到其对应的十进制数，并还原为6位二进制数，所有的6位二进制连接在一起，即为原始的二进制序列。</p>
<p>使用如下python代码实现：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x=<span class="string">&#x27;ZHV9Y6Rme6B4dGhvbl0pc80jb78taW4nX7JhY7t0&#x27;</span>;</span><br><span class="line">    flag = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">40</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">64</span>):</span><br><span class="line">            <span class="keyword">if</span> x[i] == aaa[j]:</span><br><span class="line">                flag = flag + <span class="string">&#x27;&#123;:0&gt;6&#125;&#x27;</span>.format(str(bin(j))[<span class="number">2</span>:]);</span><br><span class="line">    print(flag);</span><br></pre></td></tr></table></figure>
<p>运行之后得到二进制序列:</p>
<blockquote>
<p>011001000111010101110100011000110111010001100110011110110111000001111001011101000110100001101111011011100101111101101001011100110101111101100011011011110110110101101101011010010110111001100111010111110110001001100001011000110110101101111101</p>
</blockquote>
<p>在在线工具中将二进制转换到字符串如下图所示：</p>
<p><img src="/2020/10/12/CTF%E6%A0%A1%E8%B5%9B/forblog\blog\source\_posts\CTF校赛\image-20201012175950587.png" alt="image-20201012175950587"></p>
<h2 id="misc"><a href="#misc" class="headerlink" title="misc"></a>misc</h2><h3 id="1-Guess-The-Flag"><a href="#1-Guess-The-Flag" class="headerlink" title="1. Guess The Flag"></a>1. Guess The Flag</h3><p>这一题啊，这一题是正则表达式，但我的代码丢了怎么办。。。我口述一下别打我。。。</p>
<p>这一题是用python的正则表达式对文件中的flag进行筛选，正确的flag需满足以下条件：</p>
<blockquote>
<p>提示一：正确flag的第3位是大写字母<br>提示二：正确flag的第7位不是a到h之间的小写字母<br>提示三：正确flag的第13位是数字<br>提示四：正确flag的第24位是小写字母</p>
</blockquote>
<p>因此可根据这些提示构建正则表达式。（这里我不会写提示二，因此只筛选了提示1、3、4的内容，最后手动筛选满足提示2 的flag，即为正确的flag。</p>
<h3 id="2-糟糕的调音师"><a href="#2-糟糕的调音师" class="headerlink" title="2. 糟糕的调音师"></a>2. 糟糕的调音师</h3><p>这一题的关键在”在频谱上乱画一通”，又查了一下音频的隐写，可以在频谱图上写下flag，因此下载了工具Audacity。</p>
<p><img src="/2020/10/12/CTF%E6%A0%A1%E8%B5%9B/forblog\blog\source\_posts\CTF校赛\image-20201013204257896.png" alt="image-20201013204257896"></p>
<h3 id="3-What-remains-of-white-pagoda"><a href="#3-What-remains-of-white-pagoda" class="headerlink" title="3.What remains of white pagoda"></a>3.What remains of white pagoda</h3><p>这一题和练习题一样，缺少定位框的二维码，直接从网上找二维码把框截下来就行。</p>
<h3 id="4-白神话：悟能"><a href="#4-白神话：悟能" class="headerlink" title="4. 白神话：悟能"></a>4. 白神话：悟能</h3><p>emmm，这题其实在考察python编程？看视频首先能看到一个很突兀的黑白图片：</p>
<p><img src="/2020/10/12/CTF%E6%A0%A1%E8%B5%9B/forblog\blog\source\_posts\CTF校赛\image-20201012180811172.png" alt="image-20201012180811172"></p>
<p>这里出现了我们的老朋友DUTCTF，啊这！这一题的flag一定藏在视频里！但是视频的时长太长了！竟然有一个小时。所以想到用Python把这些帧提取出来：</p>
<p>从网上扒了一个提取帧的代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> cv2    <span class="comment">##加载OpenCV模块</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">video2frames</span>(<span class="params">pathIn=<span class="string">&#x27;&#x27;</span>, </span></span></span><br><span class="line"><span class="function"><span class="params">                 pathOut=<span class="string">&#x27;&#x27;</span>, </span></span></span><br><span class="line"><span class="function"><span class="params">                 only_output_video_info = False, </span></span></span><br><span class="line"><span class="function"><span class="params">                 extract_time_points = None, </span></span></span><br><span class="line"><span class="function"><span class="params">                 initial_extract_time = <span class="number">0</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">                 end_extract_time = None,</span></span></span><br><span class="line"><span class="function"><span class="params">                 extract_time_interval = <span class="number">-1</span>, </span></span></span><br><span class="line"><span class="function"><span class="params">                 output_prefix = <span class="string">&#x27;frame&#x27;</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">                 jpg_quality = <span class="number">100</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">                 isColor = True</span>):</span></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    pathIn：视频的路径，比如：F:\python_tutorials\test.mp4</span></span><br><span class="line"><span class="string">    pathOut：设定提取的图片保存在哪个文件夹下，比如：F:\python_tutorials\frames1\。如果该文件夹不存在，函数将自动创建它</span></span><br><span class="line"><span class="string">    only_output_video_info：如果为True，只输出视频信息（长度、帧数和帧率），不提取图片</span></span><br><span class="line"><span class="string">    extract_time_points：提取的时间点，单位为秒，为元组数据，比如，(2, 3, 5)表示只提取视频第2秒， 第3秒，第5秒图片</span></span><br><span class="line"><span class="string">    initial_extract_time：提取的起始时刻，单位为秒，默认为0（即从视频最开始提取）</span></span><br><span class="line"><span class="string">    end_extract_time：提取的终止时刻，单位为秒，默认为None（即视频终点）</span></span><br><span class="line"><span class="string">    extract_time_interval：提取的时间间隔，单位为秒，默认为-1（即输出时间范围内的所有帧）</span></span><br><span class="line"><span class="string">    output_prefix：图片的前缀名，默认为frame，图片的名称将为frame_000001.jpg、frame_000002.jpg、frame_000003.jpg......</span></span><br><span class="line"><span class="string">    jpg_quality：设置图片质量，范围为0到100，默认为100（质量最佳）</span></span><br><span class="line"><span class="string">    isColor：如果为False，输出的将是黑白图片</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    </span><br><span class="line">    cap = cv2.VideoCapture(pathIn)  <span class="comment">##打开视频文件</span></span><br><span class="line">    n_frames = int(cap.get(cv2.CAP_PROP_FRAME_COUNT))  <span class="comment">##视频的帧数</span></span><br><span class="line">    fps = cap.get(cv2.CAP_PROP_FPS)  <span class="comment">##视频的帧率</span></span><br><span class="line">    dur = n_frames/fps  <span class="comment">##视频的时间</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">##如果only_output_video_info=True, 只输出视频信息，不提取图片</span></span><br><span class="line">    <span class="keyword">if</span> only_output_video_info:</span><br><span class="line">        print(<span class="string">&#x27;only output the video information (without extract frames)::::::&#x27;</span>)</span><br><span class="line">        print(<span class="string">&quot;Duration of the video: &#123;&#125; seconds&quot;</span>.format(dur))</span><br><span class="line">        print(<span class="string">&quot;Number of frames: &#123;&#125;&quot;</span>.format(n_frames))</span><br><span class="line">        print(<span class="string">&quot;Frames per second (FPS): &#123;&#125;&quot;</span>.format(fps)) </span><br><span class="line">    </span><br><span class="line">    <span class="comment">##提取特定时间点图片</span></span><br><span class="line">    <span class="keyword">elif</span> extract_time_points <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">if</span> max(extract_time_points) &gt; dur:   <span class="comment">##判断时间点是否符合要求</span></span><br><span class="line">            <span class="keyword">raise</span> NameError(<span class="string">&#x27;the max time point is larger than the video duration....&#x27;</span>)</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            os.mkdir(pathOut)</span><br><span class="line">        <span class="keyword">except</span> OSError:</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line">        success = <span class="literal">True</span></span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> success <span class="keyword">and</span> count &lt; len(extract_time_points):</span><br><span class="line">            cap.set(cv2.CAP_PROP_POS_MSEC, (<span class="number">1000</span>*extract_time_points[count])) </span><br><span class="line">            success,image = cap.read()</span><br><span class="line">            <span class="keyword">if</span> success:</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> isColor:</span><br><span class="line">                    image = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)  <span class="comment">##转化为黑白图片</span></span><br><span class="line">                print(<span class="string">&#x27;Write a new frame: &#123;&#125;, &#123;&#125;th&#x27;</span>.format(success, count+<span class="number">1</span>))</span><br><span class="line">                cv2.imwrite(os.path.join(pathOut, <span class="string">&quot;&#123;&#125;_&#123;:06d&#125;.jpg&quot;</span>.format(output_prefix, count+<span class="number">1</span>)), image, [int(cv2.IMWRITE_JPEG_QUALITY), jpg_quality])     <span class="comment"># save frame as JPEG file</span></span><br><span class="line">                count = count + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="comment">##判断起始时间、终止时间参数是否符合要求</span></span><br><span class="line">        <span class="keyword">if</span> initial_extract_time &gt; dur:</span><br><span class="line">            <span class="keyword">raise</span> NameError(<span class="string">&#x27;initial extract time is larger than the video duration....&#x27;</span>)</span><br><span class="line">        <span class="keyword">if</span> end_extract_time <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">if</span> end_extract_time &gt; dur:</span><br><span class="line">                <span class="keyword">raise</span> NameError(<span class="string">&#x27;end extract time is larger than the video duration....&#x27;</span>)</span><br><span class="line">            <span class="keyword">if</span> initial_extract_time &gt; end_extract_time:</span><br><span class="line">                <span class="keyword">raise</span> NameError(<span class="string">&#x27;end extract time is less than the initial extract time....&#x27;</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="comment">##时间范围内的每帧图片都输出</span></span><br><span class="line">        <span class="keyword">if</span> extract_time_interval == <span class="number">-1</span>:</span><br><span class="line">            <span class="keyword">if</span> initial_extract_time &gt; <span class="number">0</span>:</span><br><span class="line">                cap.set(cv2.CAP_PROP_POS_MSEC, (<span class="number">1000</span>*initial_extract_time)) </span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                os.mkdir(pathOut)</span><br><span class="line">            <span class="keyword">except</span> OSError:</span><br><span class="line">                <span class="keyword">pass</span></span><br><span class="line">            print(<span class="string">&#x27;Converting a video into frames......&#x27;</span>)</span><br><span class="line">            <span class="keyword">if</span> end_extract_time <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                N = (end_extract_time - initial_extract_time)*fps + <span class="number">1</span></span><br><span class="line">                success = <span class="literal">True</span></span><br><span class="line">                count = <span class="number">0</span></span><br><span class="line">                <span class="keyword">while</span> success <span class="keyword">and</span> count &lt; N:</span><br><span class="line">                    success,image = cap.read()</span><br><span class="line">                    <span class="keyword">if</span> success:</span><br><span class="line">                        <span class="keyword">if</span> <span class="keyword">not</span> isColor:</span><br><span class="line">                            image = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)</span><br><span class="line">                        print(<span class="string">&#x27;Write a new frame: &#123;&#125;, &#123;&#125;/&#123;&#125;&#x27;</span>.format(success, count+<span class="number">1</span>, n_frames))</span><br><span class="line">                        cv2.imwrite(os.path.join(pathOut, <span class="string">&quot;&#123;&#125;_&#123;:06d&#125;.jpg&quot;</span>.format(output_prefix, count+<span class="number">1</span>)), image, [int(cv2.IMWRITE_JPEG_QUALITY), jpg_quality])     <span class="comment"># save frame as JPEG file</span></span><br><span class="line">                        count =  count + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                success = <span class="literal">True</span></span><br><span class="line">                count = <span class="number">0</span></span><br><span class="line">                <span class="keyword">while</span> success:</span><br><span class="line">                    success,image = cap.read()</span><br><span class="line">                    <span class="keyword">if</span> success:</span><br><span class="line">                        <span class="keyword">if</span> <span class="keyword">not</span> isColor:</span><br><span class="line">                            image = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)</span><br><span class="line">                        </span><br><span class="line">                        <span class="keyword">if</span> (image[<span class="number">0</span>:<span class="number">120</span>].any()==<span class="number">0</span>)<span class="keyword">and</span>(image.any()==<span class="number">1</span>):</span><br><span class="line">                            print(<span class="string">&#x27;Write a new frame: &#123;&#125;, &#123;&#125;/&#123;&#125;&#x27;</span>.format(success, count+<span class="number">1</span>, n_frames))</span><br><span class="line">                            cv2.imwrite(os.path.join(pathOut, <span class="string">&quot;&#123;&#125;_&#123;:06d&#125;.jpg&quot;</span>.format(output_prefix, count+<span class="number">1</span>)), image, [int(cv2.IMWRITE_JPEG_QUALITY), jpg_quality])     <span class="comment"># save frame as JPEG file</span></span><br><span class="line">                        count =  count + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">##判断提取时间间隔设置是否符合要求    </span></span><br><span class="line">        <span class="keyword">elif</span> extract_time_interval &gt; <span class="number">0</span> <span class="keyword">and</span> extract_time_interval &lt; <span class="number">1</span>/fps:</span><br><span class="line">            <span class="keyword">raise</span> NameError(<span class="string">&#x27;extract_time_interval is less than the frame time interval....&#x27;</span>)</span><br><span class="line">        <span class="keyword">elif</span> extract_time_interval &gt; (n_frames/fps):</span><br><span class="line">            <span class="keyword">raise</span> NameError(<span class="string">&#x27;extract_time_interval is larger than the duration of the video....&#x27;</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="comment">##时间范围内每隔一段时间输出一张图片</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                os.mkdir(pathOut)</span><br><span class="line">            <span class="keyword">except</span> OSError:</span><br><span class="line">                <span class="keyword">pass</span></span><br><span class="line">            print(<span class="string">&#x27;Converting a video into frames......&#x27;</span>)</span><br><span class="line">            <span class="keyword">if</span> end_extract_time <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                N = (end_extract_time - initial_extract_time)/extract_time_interval + <span class="number">1</span></span><br><span class="line">                success = <span class="literal">True</span></span><br><span class="line">                count = <span class="number">0</span></span><br><span class="line">                <span class="keyword">while</span> success <span class="keyword">and</span> count &lt; N:</span><br><span class="line">                    cap.set(cv2.CAP_PROP_POS_MSEC, (<span class="number">1000</span>*initial_extract_time+count*<span class="number">1000</span>*extract_time_interval)) </span><br><span class="line">                    success,image = cap.read()</span><br><span class="line">                    <span class="keyword">if</span> success:</span><br><span class="line">                        <span class="keyword">if</span> <span class="keyword">not</span> isColor:</span><br><span class="line">                            image = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)</span><br><span class="line">                        print(<span class="string">&#x27;Write a new frame: &#123;&#125;, &#123;&#125;th&#x27;</span>.format(success, count+<span class="number">1</span>))</span><br><span class="line">                        cv2.imwrite(os.path.join(pathOut, <span class="string">&quot;&#123;&#125;_&#123;:06d&#125;.jpg&quot;</span>.format(output_prefix, count+<span class="number">1</span>)), image, [int(cv2.IMWRITE_JPEG_QUALITY), jpg_quality])     <span class="comment"># save frame as JPEG file</span></span><br><span class="line">                        count = count + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                success = <span class="literal">True</span></span><br><span class="line">                count = <span class="number">0</span></span><br><span class="line">                <span class="keyword">while</span> success:</span><br><span class="line">                    cap.set(cv2.CAP_PROP_POS_MSEC, (<span class="number">1000</span>*initial_extract_time+count*<span class="number">1000</span>*extract_time_interval)) </span><br><span class="line">                    success,image = cap.read()</span><br><span class="line">                    <span class="keyword">if</span> success:</span><br><span class="line">                        <span class="keyword">if</span> <span class="keyword">not</span> isColor:</span><br><span class="line">                            image = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)</span><br><span class="line">                        print(<span class="string">&#x27;Write a new frame: &#123;&#125;, &#123;&#125;th&#x27;</span>.format(success, count+<span class="number">1</span>))</span><br><span class="line">                        cv2.imwrite(os.path.join(pathOut, <span class="string">&quot;&#123;&#125;_&#123;:06d&#125;.jpg&quot;</span>.format(output_prefix, count+<span class="number">1</span>)), image, [int(cv2.IMWRITE_JPEG_QUALITY), jpg_quality])     <span class="comment"># save frame as JPEG file</span></span><br><span class="line">                        count = count + <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">##### 测试</span></span><br><span class="line">pathIn = <span class="string">&#x27;C:/Users/zxkj/Desktop/temp/《白神话：悟能》PV1/《白神话：悟能》PV1.mp4&#x27;</span></span><br><span class="line"></span><br><span class="line">pathOut = <span class="string">&#x27;C:/Users/zxkj/Desktop/temp/frame/&#x27;</span></span><br><span class="line">video2frames(pathIn, pathOut)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在这个代码里，只需要在保存帧的部分做一个判断，判断这个图片是不是带有flag的图片格式（即上半部分为黑色）。修改关键代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if (image[0:120].any()&#x3D;&#x3D;0)and(image.any()&#x3D;&#x3D;1):##关键在这里</span><br><span class="line">    print(&#39;Write a new frame: &#123;&#125;, &#123;&#125;&#x2F;&#123;&#125;&#39;.format(success, count+1, n_frames))</span><br><span class="line">    cv2.imwrite(os.path.join(pathOut, &quot;&#123;&#125;_&#123;:06d&#125;.jpg&quot;.format(output_prefix, count+1)), image, [int(cv2.IMWRITE_JPEG_QUALITY), jpg_quality])     # save frame as JPEG file</span><br><span class="line">    count &#x3D;  count + 1</span><br></pre></td></tr></table></figure>
<p>这里判断当图像颜色矩阵中0到120行每个数均为0（黑色RGB值为000）时，并且图像并非全黑时，将图片保存下来。根据保存的图片和题目中的提示，可以得到完整的flag。</p>
<p><img src="/2020/10/12/CTF%E6%A0%A1%E8%B5%9B/forblog\blog\source\_posts\CTF校赛\image-20201012181543581.png" alt="image-20201012181543581"></p>
<h3 id="5-零卡攻略网"><a href="#5-零卡攻略网" class="headerlink" title="5. 零卡攻略网"></a>5. 零卡攻略网</h3><p>查阅资料可知，该题属于zip已知明文攻击，直接通过工具Archpr把签到题或第一课作为明文，零卡攻略网作为密文，进行解密即可。</p>
<p><img src="/2020/10/12/CTF%E6%A0%A1%E8%B5%9B/forblog\blog\source\_posts\CTF校赛\image-20201014074238940.png" alt="image-20201014074238940"></p>
<h3 id="6-俸俸伲-购美病"><a href="#6-俸俸伲-购美病" class="headerlink" title="6. 俸俸伲 购美病"></a>6. 俸俸伲 购美病</h3><p>题目里说在浏览器输入俸俸，浏览器中显示了淇镐扛，因此这里可以推断是URL编码的问题。这个时候就打开了我万能的<a href="http://ctf.ssleye.com/url.html">在线工具</a></p>
<p><img src="/2020/10/12/CTF%E6%A0%A1%E8%B5%9B/forblog\blog\source\_posts\CTF校赛\image-20201014075333571.png" alt="image-20201014075333571"></p>
<p>URL应该有这几种编码，如果能复现俸俸到淇镐扛的编码过程，那么也就能解密榛昏攢榛肩邯了。说干就干，这里用utf8对俸俸进行编码，再用gb2312进行解码！就出现了淇镐扛！</p>
<p>那么对榛昏攢榛肩邯进行gb2312编码，再用utf8解码，就能得到最后的flag了。（这个网站在编码过程中有问题，于是换了<a href="http://tool.haooyou.com/code?group=convert&amp;type=strToHex&amp;charset=GB2312">一个网站</a></p>
<p><img src="/2020/10/12/CTF%E6%A0%A1%E8%B5%9B/forblog\blog\source\_posts\CTF校赛\image-20201014080056973.png" alt="image-20201014080056973"></p>
<h3 id="7-偷来的密码"><a href="#7-偷来的密码" class="headerlink" title="7. 偷来的密码"></a>7. 偷来的密码</h3><p>这个文件首先发现很奇怪</p>
<p><img src="/2020/10/12/CTF%E6%A0%A1%E8%B5%9B/forblog\blog\source\_posts\CTF校赛\image-20201014081543235.png" alt="image-20201014081543235"></p>
<p>有很多长度不同的空白行，上网学习了一波，发现是whitespace编程语言……真的绝了，用<a href="https://vii5ard.github.io/whitespace/">在线编译器</a>跑一波，得到输出flag。</p>
<p><img src="/2020/10/12/CTF%E6%A0%A1%E8%B5%9B/forblog\blog\source\_posts\CTF校赛\image-20201014081801445.png" alt="image-20201014081801445"></p>
<p><em>签到题、问卷题此处忽略。。。</em></p>
<h2 id="apk"><a href="#apk" class="headerlink" title="apk"></a>apk</h2><h3 id="1-你的手机"><a href="#1-你的手机" class="headerlink" title="1. 你的手机"></a>1. 你的手机</h3><p>有了flag为四位的提示后，一切变得简单……只需要安装apk文件，再随便输点啥，屏幕下部就会不断弹出四位字符，对，那就是flag。。。</p>
]]></content>
  </entry>
  <entry>
    <title>HTTP协议</title>
    <url>/2020/08/30/HTTP%E5%8D%8F%E8%AE%AE/</url>
    <content><![CDATA[<h2 id="1-网络基础"><a href="#1-网络基础" class="headerlink" title="1. 网络基础"></a>1. 网络基础</h2><p>三项WWW构建技术：</p>
<ul>
<li>超文本标记语言HTML</li>
<li>文档传递协议HTTP</li>
<li>指定文档地址的URL</li>
</ul>
<h3 id="1-1-TCP-IP"><a href="#1-1-TCP-IP" class="headerlink" title="1.1 TCP/IP"></a>1.1 TCP/IP</h3><p>TCP/IP是互联网相关的各类协议族的总称。按照层次可分为如下四层</p>
<a id="more"></a>
<ol>
<li>应用层：向用户提供应用服务时通信的活动，包括FTP、DNS、HTTP协议</li>
<li>传输层：提供处于网络连接中两台计算机间的数据传输，包括TCP、UDP（TCP首部）</li>
<li>网络层：处理网络上流动的数据包，包括IP（IP首部）</li>
<li>数据链路层（网络接口层）：处理连接网络的硬件部分（以太网首部）</li>
</ol>
<p>客户端与服务器在进行数据传输时，客户端在应用层发送信息，服务器在链路层接收数据后，传送到应用层。</p>
<p>层与层之间进行数据传输时，客户端每层增加首部，接收端每层删除首部。</p>
<h4 id="IP协议"><a href="#IP协议" class="headerlink" title="IP协议"></a>IP协议</h4><p>IP协议位于网络层，全称Internet Protocol，很牛批有没有。TCP/IP中的IP指的就是该网际协议。</p>
<p>功能：把数据包传送到目的服务器。</p>
<p>IP地址：指明节点被分配的地址，可变换</p>
<p>MAC地址：网卡的固定地址</p>
<p>由于IP地址可变换，MAC地址不变，IP间的通信依赖MAC地址。根据ARP协议查找IP地址对应的MAC地址。</p>
<h4 id="TCP协议"><a href="#TCP协议" class="headerlink" title="TCP协议"></a>TCP协议</h4><p>TCP协议位于传输层。</p>
<p>功能：传送数据并确保是否抵达</p>
<p>方法：将大块数据分割成报文段（segment），三次握手确保数据是否抵达。</p>
<p>三次握手：flag——SYN——ACK</p>
<h4 id="DNS服务"><a href="#DNS服务" class="headerlink" title="DNS服务"></a>DNS服务</h4><p>DNS服务位于应用层。</p>
<p>功能：将域名解析为IP地址或反向解析。</p>
<h3 id="1-2-URI和URL"><a href="#1-2-URI和URL" class="headerlink" title="1.2 URI和URL"></a>1.2 URI和URL</h3><p>URI：统一资源标识符，由所用协议方案表示的资源的定位标识符，</p>
<p>URL：统一资源定位符，表示资源地点，是URI的子集。</p>
<p>绝对URI格式：</p>
<blockquote>
<p><a href="http://user:pass@www.example.jp:80/dir/index.htm?uid=1#ch1">http://user:pass@www.example.jp:80/dir/index.htm?uid=1#ch1</a></p>
</blockquote>
<p>其中</p>
<p>http：：协议方案名</p>
<p>user\:pass：登录信息</p>
<p>www(战略性).example.jp：服务器地址</p>
<p>:80：服务器端口</p>
<p>dir.index.htm?：带层次的文件路径</p>
<p>uid=1：查询字符串</p>
<p>ch1：片段标识符</p>
<h2 id="2-HTTP协议"><a href="#2-HTTP协议" class="headerlink" title="2. HTTP协议"></a>2. HTTP协议</h2><h3 id="2-1-HTTP不保存状态"><a href="#2-1-HTTP不保存状态" class="headerlink" title="2.1 HTTP不保存状态"></a>2.1 HTTP不保存状态</h3><p>HTTP协议是无状态协议，即每当有新的请求发送时，就会有对应的新响应产生，之前的一切请求和响应报文均不保留。这也导致了再保存登录状态时，需要引入Cookie技术保持状态。</p>
<p>Cookie技术通过在请求和响应报文中写入Cookie信息控制客户端状态。</p>
<p>传送过程：</p>
<p>客户端—发送请求—服务器</p>
<p>服务器—生成Cookie—客户端</p>
<p>客户端—添加Cookie—服务器</p>
<h3 id="2-2-HTTP方法"><a href="#2-2-HTTP方法" class="headerlink" title="2.2 HTTP方法"></a>2.2 HTTP方法</h3><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">名称</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">GET</td>
<td style="text-align:center">请求访问已被URI识别的资源。返回指定资源经服务器解析后的响应内容。</td>
</tr>
<tr>
<td style="text-align:center">POST</td>
<td style="text-align:center">传输实体的主体，POST的目的是传输，而不是获取响应主体</td>
</tr>
<tr>
<td style="text-align:center">PUT</td>
<td style="text-align:center">传输文件，自身不带验证机制</td>
</tr>
<tr>
<td style="text-align:center">HEAD</td>
<td style="text-align:center">与GET方法相似，不返回报文主体，确认URI的有效性和资源更新的日期</td>
</tr>
<tr>
<td style="text-align:center">DELETE</td>
<td style="text-align:center">与PUT方法相反，请求URI删除指定资源，自身不带验证机制</td>
</tr>
<tr>
<td style="text-align:center">OPTIONS</td>
<td style="text-align:center">查询对指定资源支持的方法</td>
</tr>
<tr>
<td style="text-align:center">TRACE</td>
<td style="text-align:center">让Web服务器将请求通信环回给客户端</td>
</tr>
<tr>
<td style="text-align:center">CONNECT</td>
<td style="text-align:center">要求在与代理服务器通信时建立隧道</td>
</tr>
</tbody>
</table>
</div>
<h3 id="2-3-HTTP连接特点"><a href="#2-3-HTTP连接特点" class="headerlink" title="2.3 HTTP连接特点"></a>2.3 HTTP连接特点</h3><ol>
<li>持久连接：减少TCP连接的重复建立和断开造成的额外开销</li>
<li>管线化：并行发送多个请求</li>
</ol>
<h2 id="3-HTTP报文详解"><a href="#3-HTTP报文详解" class="headerlink" title="3. HTTP报文详解"></a>3. HTTP报文详解</h2><p>什么是HTTP报文？</p>
<h3 id="3-1-HTTP报文"><a href="#3-1-HTTP报文" class="headerlink" title="3.1 HTTP报文"></a>3.1 HTTP报文</h3><p>HTTP报文由报文首部、空行、报文主体构成。</p>
<p><strong>请求报文</strong>是客户端的HTTP报文</p>
<blockquote>
<p> POST /form/entry HTTP/1.1</p>
</blockquote>
<p>POST：请求方法</p>
<p>/form/entry：请求URI</p>
<p>HTTP/1.1：协议版本</p>
<p><strong>响应报文</strong>是服务器端的HTTP报文</p>
<blockquote>
<p>HTTP/1.1 200 OK</p>
</blockquote>
<p>HTTP/1.1：协议版本</p>
<p>200：状态码</p>
<p>OK：状态码的原因短语</p>
<h4 id="报文首部"><a href="#报文首部" class="headerlink" title="报文首部"></a>报文首部</h4><p>请求报文和响应报文的首部内容由以下数据组成：</p>
<ul>
<li>请求行：请求方法、请求URI、HTTP版本</li>
<li>状态行：状态码、原因短语、HTTP版本</li>
<li>首部字段：包含表示请求和响应的各种条件和属性的各类首部</li>
<li>其他：Cookie等</li>
</ul>
<p>首部字段：</p>
<ul>
<li>通用首部字段：请求报文、响应报文都使用的首部</li>
<li>请求首部字段：从客户端向服务器端发送请求时使用的首部</li>
<li>响应首部字段：服务器向客户端</li>
<li>实体首部字段：针对报文实体部分使用</li>
</ul>
<h3 id="3-2-通用首部"><a href="#3-2-通用首部" class="headerlink" title="3.2 通用首部"></a>3.2 通用首部</h3><div class="table-container">
<table>
<thead>
<tr>
<th>字段名</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>Cache-Control</td>
<td>控制缓存的工作机制</td>
</tr>
<tr>
<td>Connection</td>
<td>控制不再转发/管理持久连接</td>
</tr>
<tr>
<td>Date</td>
<td>表明创建报文的日期和时间</td>
</tr>
<tr>
<td>Pragma</td>
<td>HTTP/1.1之前版本的遗留字段</td>
</tr>
<tr>
<td>Trailer</td>
<td>说明在报文主体后记录了哪些首部字段</td>
</tr>
<tr>
<td>Transfer-Encoding</td>
<td>规定传输报文主体时采用的编码方式</td>
</tr>
<tr>
<td>Upgrade</td>
<td>检测HTTP协议及其他协议是否能使用更高版本通信</td>
</tr>
<tr>
<td>Via</td>
<td>追踪客户端与服务器间的请求和响应报文传输路径</td>
</tr>
<tr>
<td>Warning</td>
<td>告知用户与缓存相关的问题的警告</td>
</tr>
</tbody>
</table>
</div>
<h3 id="3-3-编码"><a href="#3-3-编码" class="headerlink" title="3.3 编码"></a>3.3 编码</h3><p>在了解编码的概念之前，首先需要明白报文和实体的差别。</p>
<ul>
<li>报文：HTTP通信中的基本单位</li>
<li>实体：作为请求或响应的有效载荷数据被传输，包括实体首部和实体主体。</li>
</ul>
<p>HTTP报文的主体用于传输实体主体。</p>
<p>通常报文主体等于实体主体，只有传输中进行编码时，实体内容发生变化，与报文主体产生差异。</p>
<p>编码有以下几种：</p>
<ol>
<li>内容编码：应用在实体内容上，压缩传输</li>
<li>分块传输编码：将实体主体分成多个部分发往客户端</li>
</ol>
<h3 id="3-4-内容协商机制"><a href="#3-4-内容协商机制" class="headerlink" title="3.4 内容协商机制"></a>3.4 内容协商机制</h3><p>内容协商机制即客户端、服务器端就响应的资源内容进行交涉，提供给客户端最合适的资源。</p>
<ol>
<li>服务器驱动协商：由服务器端进行内容协商</li>
<li>客户端驱动协商：由客户端进行内容协商</li>
<li>透明协商：上述两种方法的一种结合体。</li>
</ol>
<h2 id="4-返回结果的HTTP状态码"><a href="#4-返回结果的HTTP状态码" class="headerlink" title="4. 返回结果的HTTP状态码"></a>4. 返回结果的HTTP状态码</h2><p>状态码描述返回的请求结果，由3位数字和原因短语组成。3位数字中的第一位指定响应类别，后两位无分类。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">类别</th>
<th style="text-align:center">原因短语</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1XX（信息性状态码）</td>
<td style="text-align:center">接收的请求正在处理</td>
</tr>
<tr>
<td style="text-align:center">2XX（成功状态码）</td>
<td style="text-align:center">请求正常处理完毕</td>
</tr>
<tr>
<td style="text-align:center">3XX（重定向状态码）</td>
<td style="text-align:center">需要进行附加操作以完成请求</td>
</tr>
<tr>
<td style="text-align:center">4XX（客户端错误状态码）</td>
<td style="text-align:center">服务器无法处理请求</td>
</tr>
<tr>
<td style="text-align:center">5XX（服务器错误状态码）</td>
<td style="text-align:center">服务器处理请求出错</td>
</tr>
</tbody>
</table>
</div>
<h3 id="4-1-2XX-成功"><a href="#4-1-2XX-成功" class="headerlink" title="4.1 2XX 成功"></a>4.1 2XX 成功</h3><ul>
<li>200 OK</li>
<li>204 No Content：成功处理。但返回的响应报文中不含实体主体</li>
<li>206 Parrtial Content：成功处理，返回指定范围的实体内容</li>
</ul>
<h3 id="4-2-3XX-重定向"><a href="#4-2-3XX-重定向" class="headerlink" title="4.2 3XX 重定向"></a>4.2 3XX 重定向</h3><ul>
<li>301 Moved Permanently：永久性重定向，更新URI</li>
<li>302 Found：临时重定向，资源临时更改URI，但不更新</li>
<li>303 See Other：明确指出使用GET方法获取资源</li>
<li>304 Not Modified：客户端发送附带条件的请求时，条件不满足（IF语句不满足）</li>
<li>307 Temporary Redirect：与302类似，但不会从POST变为GET</li>
</ul>
<h3 id="4-3-4XX-客户端错误"><a href="#4-3-4XX-客户端错误" class="headerlink" title="4.3 4XX 客户端错误"></a>4.3 4XX 客户端错误</h3><ul>
<li>400 Bad Request：请求报文存在语法错误</li>
<li>401 Unauthorized：第1次返回401，未认证；第2次返回401，认证失败</li>
<li>403 Forbidden：不允许访问该资源</li>
<li>404 Not Found：服务器上无此资源或拒绝说明理由</li>
</ul>
<h3 id="4-4-5XX服务器错误"><a href="#4-4-5XX服务器错误" class="headerlink" title="4.4 5XX服务器错误"></a>4.4 5XX服务器错误</h3><ul>
<li>500 Internal Server Error：服务器执行请求时发生错误</li>
<li>503 Service Unavailabel：服务器超负载或停机维护</li>
</ul>
<h2 id="5-与HTTP协作的Web服务器"><a href="#5-与HTTP协作的Web服务器" class="headerlink" title="5. 与HTTP协作的Web服务器"></a>5. 与HTTP协作的Web服务器</h2><p>一台服务器可以搭建多个Web站点，客户端访问这些站点时会映射到相同的IP地址，因此再发送HTTP请求时，需要指定主机名或域名的URI。</p>
<h3 id="5-1-通信数据转发应用程序"><a href="#5-1-通信数据转发应用程序" class="headerlink" title="5.1 通信数据转发应用程序"></a>5.1 通信数据转发应用程序</h3><p>HTTP通信时，除了客户端和服务器，还需要通信数据转发应用程序配合服务器工作。</p>
<ul>
<li>代理：转发功能，客户端和服务器通信间的中间人</li>
<li>网关：转发其他服务器通信数据的服务器，可以对客户端发送的请求进行处理。</li>
<li>隧道：在客户端和服务器间进行中转，保持双方通信连接</li>
</ul>
<h4 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h4><p>代理并不会改变请求URI</p>
<ol>
<li>缓存代理：转发响应时，代理将资源的副本保存在代理服务器上。代理再次接收到相同请求时，直接将缓存返回。</li>
<li>透明代理：不对报文做任何加工。</li>
</ol>
<h4 id="网关"><a href="#网关" class="headerlink" title="网关"></a>网关</h4><p>网关工作机制与代理类似，能使通信线路上的服务器提供非HTTP协议服务。提高通信的安全性。</p>
<h4 id="隧道"><a href="#隧道" class="headerlink" title="隧道"></a>隧道</h4><p>建立客户端与服务器的通信线路，使用SSL等加密手段，确保通信安全。</p>
<h3 id="5-2-缓存"><a href="#5-2-缓存" class="headerlink" title="5.2 缓存"></a>5.2 缓存</h3><p>利用缓存可以减少对服务器的访问，节省通信流量和时间。</p>
<p>缓存可以存在于缓存服务器和客户端浏览器中，当判定缓存过期后，会向源服务器确认资源的有效性。</p>
<h2 id="6-HTTPS"><a href="#6-HTTPS" class="headerlink" title="6. HTTPS"></a>6. HTTPS</h2><h3 id="6-1-HTTP缺点"><a href="#6-1-HTTP缺点" class="headerlink" title="6.1 HTTP缺点"></a>6.1 HTTP缺点</h3><ol>
<li>通信使用明文，解决方法：通信加密（HTTPS，基于SSL），内容加密</li>
<li>不验证通信方身份，解决方法：证书（基于SLL）</li>
<li>无法证明报文完整性，解决方法：摘要（基于SSL）</li>
</ol>
<h3 id="6-2-HTTPS介绍"><a href="#6-2-HTTPS介绍" class="headerlink" title="6.2 HTTPS介绍"></a>6.2 HTTPS介绍</h3><p>HTTPS即对HTTP添加加密、认证、完整性保护机制。添加的方法即对通信接口部分用SSL和TLS协议代替。HTTP先与SSL通信，再由SSL与TCP通信。</p>
<h4 id="SSL"><a href="#SSL" class="headerlink" title="#### SSL"></a>#### SSL</h4><p>SSL采用公开密钥加密方法。</p>
<p>共享（对称）密钥加密：加密和解密用同一个密钥，但密钥的发送无法确保安全。</p>
<p>公开（非对称）密钥加密：发送方用公开的密钥加密，接收方用私有密钥解密。</p>
<p>但是公开密钥加密与共享密钥加密相比，处理速度要慢。所以SSL利用两种方式的优势，采用混合加密方法。</p>
<p>但是在何时使用公开密钥，何时使用共享密钥呢？</p>
<p>大佬们想到了一个绝妙的主意：</p>
<ul>
<li>在交换密钥环节使用公开密钥加密</li>
<li>建立通信后，使用共享密钥加密。</li>
</ul>
<p>不过问题又来了，在隐私文件进行加密时，无法确定你拿到的密钥是目标发行的啊！若被攻击者替换了则也造成了泄密问题。</p>
<p>大佬们又想到了一个绝妙的主意。</p>
<h4 id="证书"><a href="#证书" class="headerlink" title="证书"></a>证书</h4><p>大佬们成立了一个公证机构叫数字证书认证机构（CA，Certificate Authority），公开密钥的发行者只要拿着自己的密钥到公证处认证，公证处检查合格后，就会给这个密钥签上自己的名字，客户端拿到这个签了名的公开密钥，可以进行验证。</p>
<p><strong>疑惑的一点是，客户端拿到的公开密钥是如何认证的呢？如何确保认证过程的安全性呢？</strong></p>
<p>答：客户端拿到公钥证书后，使用数字证书认证机构的公开密钥，向认证机构验证签名，而数字证书认证机构的密钥事先就植入到了浏览器里。即，CA对证书采用私钥加密，客户端用CA的公钥对加密的证书解密，若能够解密，则说明该证书确实采用了CA私钥加密，为合法证书。</p>
<p>证书除了用来证明服务器的规范性外，还可确认服务器背后运营的企业是否真实存在。该类证书叫EV SSL（Extenden Validation SSL Certificate）证书。</p>
<p>除了上述的服务器证书、EV SSL证书，还存在一种叫<strong>客户端证书</strong>的东西，服务器用来证明正在通信的客户端。但是这种证书有效嘛？</p>
<p>客户端证书存在如下几个问题：</p>
<ul>
<li>客户端证书需要用户自行安装</li>
<li>每张证书需要支付费用</li>
</ul>
<p>因此，客户端证书只用于特殊的、重要的业务中。</p>
<p>上述所有证书的有效性都建立在一个前提下，也就是认证机构的绝对可信。但是认证机构就是绝对可信的嘛？大佬们已经用实践证明，Nope!!!</p>
<p>当黑客入侵了认证机构后，就可利用该机构发布伪造证书，而且无效证书的吊销、删除都需要一段时间生效。</p>
<h3 id="6-3-HTTPS安全通信机制"><a href="#6-3-HTTPS安全通信机制" class="headerlink" title="6.3 HTTPS安全通信机制"></a>6.3 HTTPS安全通信机制</h3><p>客户端与服务器进行通信时，先协商决定加密组件，之后服务器发送密钥给客户端，客户端通过生成随机数后，经公钥加密后发往服务器，服务器正确解密该报文后，则服务器与客户端建立通信。</p>
<h2 id="7-确认访问用户身份的认证"><a href="#7-确认访问用户身份的认证" class="headerlink" title="7. 确认访问用户身份的认证"></a>7. 确认访问用户身份的认证</h2><p>某些Web页面只想让特定的人浏览，为了达到这个目的，就需要对访问者进行认证，这个时候大家可以思考一下，在进入自己的空间时，经过了哪些认证呢？</p>
<h3 id="7-1-什么是认证？"><a href="#7-1-什么是认证？" class="headerlink" title="7.1 什么是认证？"></a>7.1 什么是认证？</h3><p>为了达到确认使用者身份的问题，进行认证的信息应该是登录者本人才知道的信息，比如密码、生物认证等，但是如果你把密码泄露给别人，那也就都没辙啦！</p>
<p>在HTTP/1.1中使用的认证方式包括以下几种</p>
<ul>
<li>BASIC认证（基本认证）</li>
<li>DIGEST认证（摘要认证）</li>
<li>SSL客户端认证</li>
<li>FormBase认证（基于表单认证）</li>
</ul>
<p>下面就挨个了解一下吧！</p>
<h3 id="7-2-BASIC认证"><a href="#7-2-BASIC认证" class="headerlink" title="7.2 BASIC认证"></a>7.2 BASIC认证</h3><p>BASIC认证在HTTP/1.0就定义了这种认证方式（大概在92年，比我大多了，哭了）。但是哦！现在还有一部分网站会使用这种认证方式！真的可以说经久不衰了！</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">客户端-&gt;服务器: 发送请求</span><br><span class="line">服务器-&gt;客户端: 返回状态码401告知客户端需要进行认证</span><br><span class="line">客户端-&gt;服务器: 用户ID和密码以Base64方式编码后发送</span><br><span class="line">服务器-&gt;客户端: 认证成功返回状态码200，失败返回401</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>可以看到，在BASIC认证方式中，并没有对账号、密码进行加密，只是进行了一次编码，因此BASIC认证在HTTP这种非加密通信线路上进行BASIC认证时，相当于裸奔。</p>
<p>另外，使用BASIC认证时，一般的浏览器<strong>无法实现注销操作</strong>。这是啥意思，姐妹们想一下，你登陆了还轻易无法退出？？？离谱离谱，告辞！</p>
<h3 id="7-3-DIGEST-认证"><a href="#7-3-DIGEST-认证" class="headerlink" title="7.3 DIGEST 认证"></a>7.3 DIGEST 认证</h3><p>DIGEST认证方式是在HTTP/1.1起开始增加的，其目的主要是为了弥补BASIC认证存在的弱点。因此其认证方式也采用相同的<strong>质询/响应（challenge/response）</strong>的方式，但是不会像BASIC那样把明文密码发送过去。</p>
<p>那么它是怎样实现的呢？</p>
<p>服务器在收到客户端的访问请求时，会向客户端发送一个<strong>随机生成的质询码</strong>，并告知客户端需要认证，客户端由质询码计算出<strong>响应码</strong>，发送到服务器。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">客户端-&gt;服务器: 发送请求</span><br><span class="line">服务器-&gt;客户端: 返回状态码401和随机生成的质询码告知客户端需要进行认证</span><br><span class="line">客户端-&gt;服务器: 发送摘要和由质询码计算出的响应码</span><br><span class="line">服务器-&gt;客户端: 认证成功返回状态码200，失败返回401</span><br></pre></td></tr></table></figure>
<h3 id="7-4-SSL客户端认证"><a href="#7-4-SSL客户端认证" class="headerlink" title="7.4 SSL客户端认证"></a>7.4 SSL客户端认证</h3><p>SSL客户端认证就牛批了嗷~如果说BASIC和DIGEST只能验证账号、密码的话，那么只要密码泄露了，账号就不保了，但是SSL客户端认证可以解决这种问题。这是怎么做到的呢？？？？</p>
<p>SSL客户端在进行认证时，通过证书完成，<strong>只有获得证书的客户端</strong>，才能与服务器建立通信。</p>
<p>由于只依靠证书进行认证还是有点单薄，因此在多数情况下会采用一种<strong>双因素认证</strong>方式。所谓的双因素其实很好理解，即客户端除了要提供密码这一认证因素外，还要提供其他认证因素，相当于双重保险。</p>
<h3 id="7-5-基于表单认证"><a href="#7-5-基于表单认证" class="headerlink" title="7.5 基于表单认证"></a>7.5 基于表单认证</h3><p>首先需要明确的一点是基于表单的认证方法<strong>并不是在HTTP协议中定义</strong>的，而是由客户端向服务器上的Web应用程序发送登陆信息，按登陆信息进行验证。</p>
<p>由于不依赖于HTTP协议，因此Web应用程序可以各自实现基于表单的认证方式。安全性则有Web应用程序的设计者决定。</p>
<h4 id="7-5-1-Session管理及Cookie应用"><a href="#7-5-1-Session管理及Cookie应用" class="headerlink" title="7.5.1 Session管理及Cookie应用"></a>7.5.1 Session管理及Cookie应用</h4><p>表单的认证方法并不是在HTTP协议中定义的，但是！客户端与服务器间的通信还是要通过HTTP。</p>
<p>我们在上面已经学过了，HTTP是无状态协议**，即就算你之前已经登陆过一个网站，但这种登陆状态无法通过协议层保存下来。</p>
<p>为了解决这个问题，大佬们使用Cookie来管理Session，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">客户端-&gt;服务器: 发送已登陆信息</span><br><span class="line">服务器-&gt;客户端: 向用户发放Session ID，记录认证状态</span><br><span class="line">客户端-&gt;服务器: 发送包含Session ID的Cookie</span><br></pre></td></tr></table></figure>
<p>由于认证依赖于Session ID,所以要确保Session ID的安全性。</p>
<h2 id="8-基于HTTP的功能追加协议"><a href="#8-基于HTTP的功能追加协议" class="headerlink" title="8. 基于HTTP的功能追加协议"></a>8. 基于HTTP的功能追加协议</h2><h3 id="8-1-基于HTTP的协议"><a href="#8-1-基于HTTP的协议" class="headerlink" title="8.1 基于HTTP的协议"></a>8.1 基于HTTP的协议</h3><p>建立HTTP标准规范时，制定者主要是想把HTTP当作传输HTML文档的协议，但是没想到大家那么喜欢HTTP，并用它做了许多事情，Web传输的对象也从单纯的HTML变得多元化。但是这个时候HTTP协议已经限制了Web的性能，但是HTTP协议已经流行开来了，因此不能抛弃HTTP协议，为了弥补不足，就出台了一系列新的协议，添加了新的功能。</p>
<h3 id="8-2-消除HTTP瓶颈的SPDY"><a href="#8-2-消除HTTP瓶颈的SPDY" class="headerlink" title="8.2 消除HTTP瓶颈的SPDY"></a>8.2 消除HTTP瓶颈的SPDY</h3><p>HTTP的瓶颈？？？好大的口气小老弟！HTTP有什么瓶颈呢？</p>
<h4 id="8-2-1-HTTP的瓶颈"><a href="#8-2-1-HTTP的瓶颈" class="headerlink" title="8.2.1 HTTP的瓶颈"></a>8.2.1 HTTP的瓶颈</h4><p>首先需要充分理解瓶颈这个词，瓶颈并不是坏的，只是不够好。在Web的发展中，出现了Facebook等SNS网站，用户会实时公开发布信息，但为了在客户端实时更新，就需要从客户端进行频繁的请求，<strong>发送大量重复的信息</strong>，而客户端不管是否有信息更新，都要把数据全部发送一次，造成通信效率的低下。</p>
<p>这种问题对于用户和开发者都是难以忍受的。为了解决这个问题，大佬们提出了几种解决方法：</p>
<p><strong>Ajax的解决方法</strong></p>
<p>Ajax即（Asynchronous JavaScript and XML，异步JavaScript与XML技术），利用JavaScript和DOM的操作，以达到<strong>局部Web页面替换</strong>加载的异步通信手段。</p>
<p>艾玛！看到局部，是不是解决了上面重复信息发送的问题（滑稽）。</p>
<p>BUT！Ajax还是实时地从服务器获取内容，产生大量请求的产生，也没有解决HTTP协议本身存在的问题。</p>
<p>Ajax小老弟还是不太行，让我们看看下一个Comet同学。</p>
<p><strong>Comet的解决方法</strong></p>
<p>Comet小老弟换了一个角度解决问题，既然客户端搞不定，那就从服务器来嘛！与其等着客户端巴巴地来要，不如让服务器给客户端直接送过去。那该怎么送呢？</p>
<p>上文中说过了，HTTP协议要求请求只能从客户端开始，服务器不能主动发送，是不是绝的无解了？</p>
<p>但我们Comet小老弟是超凡绝伦的人中龙凤啊，既然客户端主动发送，那它来了之后我就扣着它，到我想发的时候，再把它送回去（即挂起）。</p>
<p>欸，乍一听好有道理的样子，但是小老弟，你这样一直挂着人家，为了维持连接会消耗更多的资源！</p>
<p>这时候SPDY看不下去了！这明显HTTP有问题，改它！</p>
<h3 id="8-2-2-SPDY的设计与功能"><a href="#8-2-2-SPDY的设计与功能" class="headerlink" title="8.2.2 SPDY的设计与功能"></a>8.2.2 SPDY的设计与功能</h3><p>SPDY并没有在原来的内容上作修改，而是在应用层（HTTP）和传输层（TCP）之间，加上了一个新的 SPDY会话层。</p>
<p>SPDY的实现还是一个很复杂的问题。咱们主要了解一下，SPDY实现了什么功能就可。</p>
<ul>
<li>多路复用流：通过单一的TCP连接，可以无限制处理多个HTTP请求</li>
<li>赋予请求优先级：为请求逐个分配优先级顺序</li>
<li>压缩HTTP首部：压缩HTTP请求和响应首部</li>
<li>推送功能：支持服务器主动向客户端推送数据</li>
<li>服务器提示功能：服务器主动提示客户端请求所需资源</li>
</ul>
<p>看来SPDY是不是很完美？人们也对SPDY抱有很大的期待，然而，然而，然而。把SPDY应用在实际的Web中并不是顺利的。而且SPDY只将单个域名的通信多路复用，当一个Web网站使用多个域名下的资源时，改善效果就会受到限制。</p>
<h3 id="8-3-使用浏览器进行全双工通信的WebSocket"><a href="#8-3-使用浏览器进行全双工通信的WebSocket" class="headerlink" title="8.3 使用浏览器进行全双工通信的WebSocket"></a>8.3 使用浏览器进行全双工通信的WebSocket</h3><p>使用Ajax和Comet技术可以提升Web浏览速度，但若使用HTTP协议，就无法彻底解决瓶颈问题。后来，大佬们就放弃更改HTTP的方法了，实现了一套新的协议WebSocket。</p>
<p>WebSocket究竟是个啥，竟然那么牛？</p>
<h4 id="8-3-1-啥是WebSocket？"><a href="#8-3-1-啥是WebSocket？" class="headerlink" title="8.3.1 啥是WebSocket？"></a>8.3.1 啥是WebSocket？</h4><p>WebSocket即Web浏览器与Web服务器间的全双工通信标准。</p>
<p>一旦服务器与客户端间建立起WebSocket协议的通信连接，之后所有的通信都依靠Websocket通信。</p>
<p>WebSocket有以下特点:</p>
<ul>
<li>推送功能</li>
<li>减少通信量：由于Websocket首部信息下，通信量也减少了</li>
</ul>
<p>使用WebSocket之前，需要由客户端向服务器发出握手请求，服务器响应之后转换为Websocket协议。</p>
<h3 id="8-4-HTTP-2-0吹爆"><a href="#8-4-HTTP-2-0吹爆" class="headerlink" title="8.4 HTTP/2.0吹爆"></a>8.4 HTTP/2.0吹爆</h3><p>HTTP/2.0是在2014年实现标准化，目标是改善用户在使用Web时的速度体验。</p>
<p>（由于本书在发行时，HTTP/2.0尚未发行，因此书中没有相关介绍）</p>
<h3 id="8-5-Web服务器管理文件的WebDAV"><a href="#8-5-Web服务器管理文件的WebDAV" class="headerlink" title="8.5 Web服务器管理文件的WebDAV"></a>8.5 Web服务器管理文件的WebDAV</h3><p>WebDAV即（Web-based Distributed Authoring and Versioning），可对Web服务器上的内容直接进行文件复制、编辑等操作的分布式文件系统。</p>
<p>针对服务器上的资源WebDav又增加了一些概念、方法及状态码。</p>
<h2 id="9-构建Web内容的技术"><a href="#9-构建Web内容的技术" class="headerlink" title="9. 构建Web内容的技术"></a>9. 构建Web内容的技术</h2><h3 id="9-1-HTML"><a href="#9-1-HTML" class="headerlink" title="9.1 HTML"></a>9.1 HTML</h3><h4 id="9-1-1-什么是超文本标记语言？"><a href="#9-1-1-什么是超文本标记语言？" class="headerlink" title="9.1.1 什么是超文本标记语言？"></a>9.1.1 什么是超文本标记语言？</h4><p>HTML即超文本标记语言，是为了发送Web上的超文本而开发的标记语言。这里的超文本和标记是个啥东东？</p>
<p><strong>Hypertext</strong>，即超文本，也可以叫做超链接文本，本质上是一种文档系统，可将文档中任意位置的信息与其他信息建立关联。</p>
<p><strong>标记语言</strong>即通过在文档的某部分穿插特别的字符串标签，用来修饰文档的语言。在HTML文档中出现的标签为HTML标签。</p>
<h4 id="9-1-2-设计应用CSS"><a href="#9-1-2-设计应用CSS" class="headerlink" title="9.1.2 设计应用CSS"></a>9.1.2 设计应用CSS</h4><p>CSS即层叠样式表，指定HTML中各种元素的展现方式。使用CSS将文档的<strong>结构</strong>和<strong>设计</strong>分离。</p>
<h3 id="9-2-动态HTML"><a href="#9-2-动态HTML" class="headerlink" title="9.2 动态HTML"></a>9.2 动态HTML</h3><p>动态HTML即通过调用JavaScript实现对HTML的Web页面的动态改造，利用DOM指定欲发生动态变化的HTML元素。</p>
<p>DOM即用以操作HTML文档和XML文档的API，使用DOM可以将HTML内的元素当对象操作。而JavaScript则是一种更简单的操作DOM的方式。</p>
<h3 id="9-3-Web应用"><a href="#9-3-Web应用" class="headerlink" title="9.3 Web应用"></a>9.3 Web应用</h3><p>Web应用指通过Web功能提供的应用程序。Web应用作用于动态内容之上。什么是动态内容呢？</p>
<p>动态内容即由Web服务器上的程序创建的HTML内容。</p>
<h4 id="9-3-1-CGI"><a href="#9-3-1-CGI" class="headerlink" title="9.3.1 CGI"></a>9.3.1 CGI</h4><p>CGI即Common Gateway Interface，是Web服务器在接收到客户端发送来的请求后转发给程序的一组机制。</p>
<p>使用CGI的程序叫做CGI程序，有PHP等编程语言写成。</p>
<h4 id="9-3-2-Servlet"><a href="#9-3-2-Servlet" class="headerlink" title="9.3.2 Servlet"></a>9.3.2 Servlet</h4><p>Servlet是用来代替CGI的在服务器上创建动态内容的程序。为什么要把CGI替换掉呢？因为CGI有缺点呗！</p>
<p>CGI在每次接到请求时，程序都会跟着启动一次，当访问量过大时，服务器负载较大。</p>
<p>而Servlet运行的环境Web容器或Servlet容器中，与Web服务器在相同的进程中。</p>
<h3 id="9-4-数据发布的格式及语言"><a href="#9-4-数据发布的格式及语言" class="headerlink" title="9.4 数据发布的格式及语言"></a>9.4 数据发布的格式及语言</h3><h4 id="9-4-1-XML（eXtensible-Markup-Language）"><a href="#9-4-1-XML（eXtensible-Markup-Language）" class="headerlink" title="9.4.1 XML（eXtensible Markup Language）"></a>9.4.1 XML（eXtensible Markup Language）</h4><p>XML是可按应用目标进行扩展的通用标记语言，旨在通过使用XML使互联网数据共享变得容易。</p>
<p>XML和HTML都是从SGML简化而成，从XML文档读取数据比从HTML更为简单。</p>
<h4 id="9-4-2-发布更新信息的RSS-Atom"><a href="#9-4-2-发布更新信息的RSS-Atom" class="headerlink" title="9.4.2 发布更新信息的RSS/Atom"></a>9.4.2 发布更新信息的RSS/Atom</h4><p>RSS和Atom都是发布新闻、博客等更新信息文档的格式的总称，都用到了XML。</p>
<h4 id="9-4-3-JSON"><a href="#9-4-3-JSON" class="headerlink" title="9.4.3 JSON"></a>9.4.3 JSON</h4><p>JSON是一种轻量级数据标记语言。</p>
<h2 id="10-Web的攻击技术"><a href="#10-Web的攻击技术" class="headerlink" title="10. Web的攻击技术"></a>10. Web的攻击技术</h2><h3 id="10-1-针对Web的攻击技术"><a href="#10-1-针对Web的攻击技术" class="headerlink" title="10.1 针对Web的攻击技术"></a>10.1 针对Web的攻击技术</h3><p>在学习Web的攻击之前，首先需要明确的是，攻击对象是什么？简单的HTTP协议并不存在安全性问题，使用HTTP的才是攻击目标。包括<strong>服务器、客户端、运行在服务器上的Web应用等资源</strong>。</p>
<p>由于HTTP协议在安全性方面呈劣势，开发者需要自行设计开发认证、会话管理功能来满足Web应用的安全需求，因此存在着多种多样的Bug。</p>
<h4 id="10-1-2-针对Web应用的攻击模式"><a href="#10-1-2-针对Web应用的攻击模式" class="headerlink" title="10.1.2 针对Web应用的攻击模式"></a>10.1.2 针对Web应用的攻击模式</h4><p>对Web应用的攻击有主动攻击和被动攻击两种。</p>
<ul>
<li>以服务器为目标的主动攻击：通过直接访问传入攻击代码，获得服务器资源。如SQL注入。</li>
<li>以服务器为目标的被动攻击：利用圈套策略执行攻击代码。如跨站脚本攻击。</li>
<li>利用用户的身份攻击企业内部网络：设置陷阱诱导内网用户触发。</li>
</ul>
<h3 id="10-2-因输出值转义不完全引发的安全漏洞"><a href="#10-2-因输出值转义不完全引发的安全漏洞" class="headerlink" title="10.2 因输出值转义不完全引发的安全漏洞"></a>10.2 因输出值转义不完全引发的安全漏洞</h3><p>要想找到安全漏洞，就要Web应用的安全对策，Web应用的安全对策可分为以下两部分：</p>
<ul>
<li>客户端的验证</li>
<li>Web应用端的验证（输入值验证、输出值转义）</li>
</ul>
<p>客户端的验证是采用JavaScript在客户端验证数据，但在客户端允许篡改数据或关闭JavaScript，不适合作为安全防范对策，但为啥还要保留呢？辨识输入错误，可以提高UI体验。</p>
<p>Web应用端的输入值验证用来检查输入值是否符合逻辑。</p>
<p>Web应用端的输出值转移是针对输出值做转义处理。</p>
<h4 id="10-2-1-跨站脚本攻击"><a href="#10-2-1-跨站脚本攻击" class="headerlink" title="10.2.1 跨站脚本攻击"></a>10.2.1 跨站脚本攻击</h4><p>跨站脚本攻击指通过存在安全漏洞的Web网站浏览器内运行非法的<strong>HTML标签</strong>或<strong>JavaScript</strong>进行的攻击。</p>
<p>可以实现以下功能：</p>
<ul>
<li>利用虚假表单骗取用户信息</li>
<li>利用脚本窃取Cookie值，帮助攻击者发送恶意请求。</li>
<li>显示伪造文章或图片。</li>
</ul>
<h4 id="10-2-2-SQL注入攻击"><a href="#10-2-2-SQL注入攻击" class="headerlink" title="10.2.2 SQL注入攻击"></a>10.2.2 SQL注入攻击</h4><p>在理解SQL注入之前，首先要知道何为SQL？</p>
<blockquote>
<p>SQL是用来操作关系型数据库管理系统的数据库语言，著名的数据库有Oracal、SQL Server</p>
<p>MySQL等。</p>
</blockquote>
<p>SQL注入是指对Web应用使用的数据库，运行非法的SQL产生的攻击。可能会造成如下影响：</p>
<ul>
<li>非法查看、篡改数据库内的数据</li>
<li>规避认证</li>
<li>执行和数据库服务器业务关联的程序</li>
</ul>
<h4 id="10-2-3-OS命令注入攻击"><a href="#10-2-3-OS命令注入攻击" class="headerlink" title="10.2.3 OS命令注入攻击"></a>10.2.3 OS命令注入攻击</h4><p>OS命令注入攻击是指通过Web应用，执行非法的<strong>操作系统命令</strong>达到攻击的目的。那么是如何在Web应用中调用操作系统命令的呢？Web应用中通过Shell实现调用操作系统命令。</p>
<h4 id="10-2-4-HTTP首部注入攻击"><a href="#10-2-4-HTTP首部注入攻击" class="headerlink" title="10.2.4 HTTP首部注入攻击"></a>10.2.4 HTTP首部注入攻击</h4><p>HTTP首部注入攻击指攻击者咋响应首部字段插入换行、添加任意响应首部、主体的一种攻击。</p>
<p>可能会产生如下影响：</p>
<ul>
<li>设置任何Cookie信息</li>
<li>重定向至任意URL</li>
<li>显示任意主体</li>
</ul>
<h4 id="10-2-5-邮件首部注入攻击"><a href="#10-2-5-邮件首部注入攻击" class="headerlink" title="10.2.5 邮件首部注入攻击"></a>10.2.5 邮件首部注入攻击</h4><p>攻击者通过向邮件首部To或Subject内任意添加非法内容发起攻击。可以实现对任意邮件地址发送广告邮件或病毒邮件。</p>
<h4 id="10-2-6-目录遍历攻击"><a href="#10-2-6-目录遍历攻击" class="headerlink" title="10.2.6 目录遍历攻击"></a>10.2.6 目录遍历攻击</h4><p>对本无意公开的文件目录，通过非法截断路径后，达成访问目的的一种攻击。</p>
<h4 id="10-2-7-远程文件包含漏洞"><a href="#10-2-7-远程文件包含漏洞" class="headerlink" title="10.2.7 远程文件包含漏洞"></a>10.2.7 远程文件包含漏洞</h4><p>当部分脚本内容需要从其他文件读入时，攻击者利用指定外部服务器的URL充当依赖文件，脚本读取后，就可运行任意脚本的一种攻击。</p>
<h3 id="10-3-因设置或设计上的缺陷引发的安全漏洞"><a href="#10-3-因设置或设计上的缺陷引发的安全漏洞" class="headerlink" title="10.3 因设置或设计上的缺陷引发的安全漏洞"></a>10.3 因设置或设计上的缺陷引发的安全漏洞</h3><h4 id="10-3-1-强制浏览"><a href="#10-3-1-强制浏览" class="headerlink" title="10.3.1 强制浏览"></a>10.3.1 强制浏览</h4><p>功能：从安置在Web服务器的公开目录下的文件中，浏览非自愿公开的文件。</p>
<p>强制浏览可能造成以下影响：</p>
<ul>
<li>泄露顾客个人信息</li>
<li>泄露需要访问权限可查阅的内容</li>
<li>泄露未外连的文件</li>
</ul>
<h4 id="10-3-2-不正确的错误消息处理"><a href="#10-3-2-不正确的错误消息处理" class="headerlink" title="10.3.2 不正确的错误消息处理"></a>10.3.2 不正确的错误消息处理</h4><p>这个其实很好理解，Web应用的错误信息包含对攻击者有用的信息。</p>
<p>包括如下几种：</p>
<ul>
<li>Web应用抛出的错误信息</li>
<li>数据库等系统抛出的错误信息</li>
</ul>
<h4 id="10-3-3-开放重定向"><a href="#10-3-3-开放重定向" class="headerlink" title="10.3.3 开放重定向"></a>10.3.3 开放重定向</h4><p>指定的重定向URL到某个恶意的Web网站。</p>
<h3 id="10-4-因会话管理疏忽引发的安全漏洞"><a href="#10-4-因会话管理疏忽引发的安全漏洞" class="headerlink" title="10.4 因会话管理疏忽引发的安全漏洞"></a>10.4 因会话管理疏忽引发的安全漏洞</h3><h4 id="10-4-1-会话劫持"><a href="#10-4-1-会话劫持" class="headerlink" title="10.4.1 会话劫持"></a>10.4.1 会话劫持</h4><p>攻击者利用用户的会话ID伪装成用户，达到攻击的目的。</p>
<p>那么何为会话ID呢？</p>
<p>会话ID是具备认证功能的Web应用的会话管理机制，服务器端将会话ID与认证状态一对一匹配。</p>
<h4 id="10-4-2-会话固定攻击"><a href="#10-4-2-会话固定攻击" class="headerlink" title="10.4.2 会话固定攻击"></a>10.4.2 会话固定攻击</h4><p>强制用户使用攻击者指定的会话ID。</p>
<p>攻击者先访问网站申请得到一个会话ID,之后诱导用户使用该会话ID完成认证。</p>
<h4 id="10-4-3-跨站点请求伪造"><a href="#10-4-3-跨站点请求伪造" class="headerlink" title="10.4.3 跨站点请求伪造"></a>10.4.3 跨站点请求伪造</h4><p>攻击者通过设置陷阱，强制对已完成认证的用户进行非预期的个人信息或设定信息等某些状态更新，属于被动攻击。</p>
<p>可能造成如下影响：</p>
<ul>
<li>更新设定信息</li>
<li>购买商品</li>
<li>在留言板发表言论</li>
</ul>
<h3 id="10-5-其他安全漏洞"><a href="#10-5-其他安全漏洞" class="headerlink" title="10.5 其他安全漏洞"></a>10.5 其他安全漏洞</h3><h4 id="10-5-1-密码破解"><a href="#10-5-1-密码破解" class="headerlink" title="10.5.1 密码破解"></a>10.5.1 密码破解</h4><p>密码破解有以下两种手段：</p>
<ul>
<li>通过网络的密码试错</li>
<li>对已加密密码的破解（获得加密或散列处理的密码数据）</li>
</ul>
<h4 id="10-5-2-点击劫持"><a href="#10-5-2-点击劫持" class="headerlink" title="10.5.2 点击劫持"></a>10.5.2 点击劫持</h4><p>利用透明的按钮或链接，诱使用户在不知情的情况下点击链接。</p>
<h4 id="10-5-3-DoS攻击"><a href="#10-5-3-DoS攻击" class="headerlink" title="10.5.3 DoS攻击"></a>10.5.3 DoS攻击</h4><p>DoS攻击让运行中的服务呈停止状态，攻击对象不仅限于Web网站，包括网络设备、服务器等。主要有如下两种DoS攻击方式：</p>
<ul>
<li>集中利用访问请求造成资源过载，资源用尽时，服务停止。</li>
<li>攻击安全漏洞使服务停止。</li>
</ul>
<p>这里！多台计算机发起的DoS攻击叫做DDoS攻击，多台计算机通常利用感染病毒的计算机作为攻击者的攻击跳板。</p>
<h4 id="10-5-4-后门程序"><a href="#10-5-4-后门程序" class="headerlink" title="10.5.4 后门程序"></a>10.5.4 后门程序</h4><p>后门程序是开发设置的隐藏入口，可以由攻击者通过某种方法设置，比较难被发现。</p>
<h2 id="完结撒花"><a href="#完结撒花" class="headerlink" title="完结撒花"></a>完结撒花</h2><p>一本两百多页的书，其实也是断断续续读了尽一个月，对网络有了一个比较深入的认识，相信这些会在计算机网络的学习中，助我更上一层楼，加油！！！</p>
<p>下本书见。</p>
]]></content>
      <tags>
        <tag>home</tag>
      </tags>
  </entry>
</search>
