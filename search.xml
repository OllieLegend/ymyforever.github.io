<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Computer Networks and the Internet</title>
    <url>/2020/09/16/Internet/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>开始读这本神奇的书了，嗯，英文版，嗯，八百多页。在这期间不打算开新的书了，这些足够我读一段时间了。</p>
<p>Keep on moving!</p>
<p>同学说800多页这学期读不完的，每天20页还需要一个多月去读。首先呢，这本书不一定要读完，重点的是靠这本书快速入门；开了这么多书，你一定要坚持住嗷~</p>
<p>读英文真的需要心无旁骛，不然一会就不知道读的是啥了，哭哭！</p>
<h2 id="1-什么是Internet？"><a href="#1-什么是Internet？" class="headerlink" title="1  什么是Internet？"></a>1  什么是Internet？</h2><h3 id="1-1-Internet的组成"><a href="#1-1-Internet的组成" class="headerlink" title="1.1 Internet的组成"></a>1.1 Internet的组成</h3><p>Internet是一种计算机网络将世界上的计算装置连接起来。所有被连接起来的装置称为主机或终端系统。</p>
<p>终端系统由communication links和packet switiches组成的网络相连。</p>
<ul>
<li>communication links由许多种，有光纤、铜线等多种。不同的类型有不同的传输速度。</li>
<li>packet switch把packets传送到它们最终的目的地。在今天的Internet中，最优秀的packet switch是路由器和链路层交换机（link-layer switches）。</li>
</ul>
<p>作者给了一个<strong>非常巧妙</strong>的比喻：</p>
<p>packets就像货车，communication links就像高速路，packet switch就是交叉路口，终端系统就像建筑。</p>
<p>货车在运输网络中前行；packet在计算机网络中前行。</p>
<p>终端系统是怎么接入网络的呢？</p>
<p>终端系统通过ISPs（Internet Service Providers）接入网络，包括住宅ISP、校园ISP等。这里你又该疑惑了，什么是ISP呢？</p>
<p>ISP本身是packet switches和communication links组成的网络，ISP提供多种接入网络的方式，包括小区宽带、无线等。</p>
<p>终端系统、packet switches等其他部分运行控制信息收发的协议。在互联网中最重要的协议有TCP（Transmission Control Protocol）协议和IP（Internet Protocol）协议。</p>
<ul>
<li>IP协议：说明包的格式</li>
</ul>
<h3 id="1-2-Internet提供的服务"><a href="#1-2-Internet提供的服务" class="headerlink" title="1.2 Internet提供的服务"></a>1.2 Internet提供的服务</h3><p>Internet是向用户提供服务的基础设施。</p>
<p>这里作者又给出了一个比喻，就像在写信时要遵守规则写上收件人、住址，网络间通信时，也要遵守一定的规则。</p>
<h3 id="1-3-什么是协议（Protocol）"><a href="#1-3-什么是协议（Protocol）" class="headerlink" title="1.3 什么是协议（Protocol）"></a>1.3 什么是协议（Protocol）</h3><p>怕不怕，抽不抽象（手动狗头）</p>
<p>聪明的读者不用害怕，作者又举例子了。</p>
<p>计算机与服务器间的信息传递过程，就像人与人之间的过程一样。</p>
<p>在我们连接网页时，我们的计算机会首先发出连接请求，Web服务器接收到请求后会给出一个回应，计算机接收到许可回应后，会把想要访问的资源名称发送给服务器，Web服务器会把资源发送给计算机。</p>
<p>在这个过程中信息的交换等协议的关键定义元素。</p>
<h2 id="2-网络的边缘"><a href="#2-网络的边缘" class="headerlink" title="2. 网络的边缘"></a>2. 网络的边缘</h2><p>什么是网络的边缘？</p>
<p>网络的边缘包括上文中提到的各种终端和主机。它们在整个网络中处于边缘位置，所以称为网络的边缘。</p>
<h3 id="2-1-网络的边缘怎么连接网络？"><a href="#2-1-网络的边缘怎么连接网络？" class="headerlink" title="2.1 网络的边缘怎么连接网络？"></a>2.1 网络的边缘怎么连接网络？</h3>]]></content>
  </entry>
  <entry>
    <title>HelloWorld!</title>
    <url>/2020/08/29/HelloWorld/</url>
    <content><![CDATA[<h2 id="A-new-world"><a href="#A-new-world" class="headerlink" title="A new world!"></a>A new world!</h2><p>哈喽！历经一个下午博客终于搭建好了，原来是那么容易的一件事情，大一的时候想的很复杂，迟迟没能动手，现在也终于有了自己的小博客啦~</p>
<p>未来灌水的文章还是会首先发在CSDN上，这里会分享一些重大的经历~已经大三了！要更努力学习！不要被些奇奇怪怪的事情干扰，奥里给！</p>
]]></content>
  </entry>
  <entry>
    <title>aDream</title>
    <url>/2020/09/15/aDream/</url>
    <content><![CDATA[<p>为什么会做这样的一场梦呢？</p>
<p>为什么做了还让我醒来呢？</p>
<p>这大概是我最不愿意醒来的梦吧。</p>
<p>求不得，求不得，求不得。</p>
<p>小的时候也做过这种怅然若失的梦，那个时候想要漂亮的文具，现在呢，想要完美的感情。</p>
<p>不过是想要得到偶像的认可罢了。</p>
<p>认可是自己给的，不要再傻了。</p>
<p>加油吧！</p>
<p>最后，真好，我还有这一方自由乐园。</p>
]]></content>
  </entry>
  <entry>
    <title>littletalk</title>
    <url>/2020/09/14/littletalk/</url>
    <content><![CDATA[<p>也许这就是偶像吧。每一次新的发现都能给我很大的精神震撼。</p>
<blockquote>
<p>我一直以为庸人才应当在规则中生活，我这种疯子才应当指定规则。</p>
</blockquote>
<blockquote>
<p>人生短暂，我们来不及循规蹈矩。</p>
</blockquote>
<blockquote>
<p>我的生活永远与众不同。</p>
</blockquote>
<p>这是多么狂妄自大的话啊，从我认识的其他任何一个人嘴里说出来都显得如此违和，只有你，你配得上这句话。</p>
<p>我是一个在规则内循规蹈矩惯了的人，甚至利用规则谋求自己的利益。也是为了父母的规则，因为恐惧，恐惧父母得知女儿竟然和女生搅在一起时，那对我是灭顶之灾。</p>
<p>所以我选择了放弃，长痛不如短痛的放弃。我还爱吗？我告诉自己不爱了。</p>
<p>大学两年来，碌碌无为，既没有增长专业知识，也没有做出什么了不起的事情。我只是校园里千万颗齿轮里的一个，大齿轮，小齿轮，都是齿轮而已。</p>
<p>仰山之高，往往自惭形秽。可是功夫没到家，你没有资格。</p>
<p>对自己狠一点，再狠一点，你想要的，没人会给你，除了自己。</p>
<p>成为盖世英雄，而不要傻傻在原地等着。</p>
<p>你要的认可与肯定，只有自己能给你。</p>
<p>循此苦旅，循此苦旅。</p>
]]></content>
  </entry>
  <entry>
    <title>HTTP协议</title>
    <url>/2020/08/30/HTTP%E5%8D%8F%E8%AE%AE/</url>
    <content><![CDATA[<h2 id="1-网络基础"><a href="#1-网络基础" class="headerlink" title="1. 网络基础"></a>1. 网络基础</h2><p>三项WWW构建技术：</p>
<ul>
<li>超文本标记语言HTML</li>
<li>文档传递协议HTTP</li>
<li>指定文档地址的URL</li>
</ul>
<h3 id="1-1-TCP-IP"><a href="#1-1-TCP-IP" class="headerlink" title="1.1 TCP/IP"></a>1.1 TCP/IP</h3><p>TCP/IP是互联网相关的各类协议族的总称。按照层次可分为如下四层</p>
<ol>
<li>应用层：向用户提供应用服务时通信的活动，包括FTP、DNS、HTTP协议</li>
<li>传输层：提供处于网络连接中两台计算机间的数据传输，包括TCP、UDP（TCP首部）</li>
<li>网络层：处理网络上流动的数据包，包括IP（IP首部）</li>
<li>数据链路层（网络接口层）：处理连接网络的硬件部分（以太网首部）</li>
</ol>
<p>客户端与服务器在进行数据传输时，客户端在应用层发送信息，服务器在链路层接收数据后，传送到应用层。</p>
<p>层与层之间进行数据传输时，客户端每层增加首部，接收端每层删除首部。</p>
<h4 id="IP协议"><a href="#IP协议" class="headerlink" title="IP协议"></a>IP协议</h4><p>IP协议位于网络层，全称Internet Protocol，很牛批有没有。TCP/IP中的IP指的就是该网际协议。</p>
<p>功能：把数据包传送到目的服务器。</p>
<p>IP地址：指明节点被分配的地址，可变换</p>
<p>MAC地址：网卡的固定地址</p>
<p>由于IP地址可变换，MAC地址不变，IP间的通信依赖MAC地址。根据ARP协议查找IP地址对应的MAC地址。</p>
<h4 id="TCP协议"><a href="#TCP协议" class="headerlink" title="TCP协议"></a>TCP协议</h4><p>TCP协议位于传输层。</p>
<p>功能：传送数据并确保是否抵达</p>
<p>方法：将大块数据分割成报文段（segment），三次握手确保数据是否抵达。</p>
<p>三次握手：flag——SYN——ACK</p>
<h4 id="DNS服务"><a href="#DNS服务" class="headerlink" title="DNS服务"></a>DNS服务</h4><p>DNS服务位于应用层。</p>
<p>功能：将域名解析为IP地址或反向解析。</p>
<h3 id="1-2-URI和URL"><a href="#1-2-URI和URL" class="headerlink" title="1.2 URI和URL"></a>1.2 URI和URL</h3><p>URI：统一资源标识符，由所用协议方案表示的资源的定位标识符，</p>
<p>URL：统一资源定位符，表示资源地点，是URI的子集。</p>
<p>绝对URI格式：</p>
<blockquote>
<p><a href="http://user:pass@www.example.jp/dir/index.htm?uid=1#ch1">http://user:pass@www.example.jp:80/dir/index.htm?uid=1#ch1</a></p>
</blockquote>
<p>其中</p>
<p>http：：协议方案名</p>
<p>user:pass：登录信息</p>
<p>www(战略性).example.jp：服务器地址</p>
<p>:80：服务器端口</p>
<p>dir.index.htm?：带层次的文件路径</p>
<p>uid=1：查询字符串</p>
<p>ch1：片段标识符</p>
<h2 id="2-HTTP协议"><a href="#2-HTTP协议" class="headerlink" title="2. HTTP协议"></a>2. HTTP协议</h2><h3 id="2-1-HTTP不保存状态"><a href="#2-1-HTTP不保存状态" class="headerlink" title="2.1 HTTP不保存状态"></a>2.1 HTTP不保存状态</h3><p>HTTP协议是无状态协议，即每当有新的请求发送时，就会有对应的新响应产生，之前的一切请求和响应报文均不保留。这也导致了再保存登录状态时，需要引入Cookie技术保持状态。</p>
<p>Cookie技术通过在请求和响应报文中写入Cookie信息控制客户端状态。</p>
<p>传送过程：</p>
<p>客户端—发送请求—服务器</p>
<p>服务器—生成Cookie—客户端</p>
<p>客户端—添加Cookie—服务器</p>
<h3 id="2-2-HTTP方法"><a href="#2-2-HTTP方法" class="headerlink" title="2.2 HTTP方法"></a>2.2 HTTP方法</h3><table>
<thead>
<tr>
<th align="center">名称</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">GET</td>
<td align="center">请求访问已被URI识别的资源。返回指定资源经服务器解析后的响应内容。</td>
</tr>
<tr>
<td align="center">POST</td>
<td align="center">传输实体的主体，POST的目的是传输，而不是获取响应主体</td>
</tr>
<tr>
<td align="center">PUT</td>
<td align="center">传输文件，自身不带验证机制</td>
</tr>
<tr>
<td align="center">HEAD</td>
<td align="center">与GET方法相似，不返回报文主体，确认URI的有效性和资源更新的日期</td>
</tr>
<tr>
<td align="center">DELETE</td>
<td align="center">与PUT方法相反，请求URI删除指定资源，自身不带验证机制</td>
</tr>
<tr>
<td align="center">OPTIONS</td>
<td align="center">查询对指定资源支持的方法</td>
</tr>
<tr>
<td align="center">TRACE</td>
<td align="center">让Web服务器将请求通信环回给客户端</td>
</tr>
<tr>
<td align="center">CONNECT</td>
<td align="center">要求在与代理服务器通信时建立隧道</td>
</tr>
</tbody></table>
<h3 id="2-3-HTTP连接特点"><a href="#2-3-HTTP连接特点" class="headerlink" title="2.3 HTTP连接特点"></a>2.3 HTTP连接特点</h3><ol>
<li>持久连接：减少TCP连接的重复建立和断开造成的额外开销</li>
<li>管线化：并行发送多个请求</li>
</ol>
<h2 id="3-HTTP报文详解"><a href="#3-HTTP报文详解" class="headerlink" title="3. HTTP报文详解"></a>3. HTTP报文详解</h2><p>什么是HTTP报文？</p>
<h3 id="3-1-HTTP报文"><a href="#3-1-HTTP报文" class="headerlink" title="3.1 HTTP报文"></a>3.1 HTTP报文</h3><p>HTTP报文由报文首部、空行、报文主体构成。</p>
<p><strong>请求报文</strong>是客户端的HTTP报文</p>
<blockquote>
<p> POST /form/entry HTTP/1.1</p>
</blockquote>
<p>POST：请求方法</p>
<p>/form/entry：请求URI</p>
<p>HTTP/1.1：协议版本</p>
<p><strong>响应报文</strong>是服务器端的HTTP报文</p>
<blockquote>
<p>HTTP/1.1 200 OK</p>
</blockquote>
<p>HTTP/1.1：协议版本</p>
<p>200：状态码</p>
<p>OK：状态码的原因短语</p>
<h4 id="报文首部"><a href="#报文首部" class="headerlink" title="报文首部"></a>报文首部</h4><p>请求报文和响应报文的首部内容由以下数据组成：</p>
<ul>
<li>请求行：请求方法、请求URI、HTTP版本</li>
<li>状态行：状态码、原因短语、HTTP版本</li>
<li>首部字段：包含表示请求和响应的各种条件和属性的各类首部</li>
<li>其他：Cookie等</li>
</ul>
<p>首部字段：</p>
<ul>
<li>通用首部字段：请求报文、响应报文都使用的首部</li>
<li>请求首部字段：从客户端向服务器端发送请求时使用的首部</li>
<li>响应首部字段：服务器向客户端</li>
<li>实体首部字段：针对报文实体部分使用</li>
</ul>
<h3 id="3-2-通用首部"><a href="#3-2-通用首部" class="headerlink" title="3.2 通用首部"></a>3.2 通用首部</h3><table>
<thead>
<tr>
<th>字段名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Cache-Control</td>
<td>控制缓存的工作机制</td>
</tr>
<tr>
<td>Connection</td>
<td>控制不再转发/管理持久连接</td>
</tr>
<tr>
<td>Date</td>
<td>表明创建报文的日期和时间</td>
</tr>
<tr>
<td>Pragma</td>
<td>HTTP/1.1之前版本的遗留字段</td>
</tr>
<tr>
<td>Trailer</td>
<td>说明在报文主体后记录了哪些首部字段</td>
</tr>
<tr>
<td>Transfer-Encoding</td>
<td>规定传输报文主体时采用的编码方式</td>
</tr>
<tr>
<td>Upgrade</td>
<td>检测HTTP协议及其他协议是否能使用更高版本通信</td>
</tr>
<tr>
<td>Via</td>
<td>追踪客户端与服务器间的请求和响应报文传输路径</td>
</tr>
<tr>
<td>Warning</td>
<td>告知用户与缓存相关的问题的警告</td>
</tr>
</tbody></table>
<h3 id="3-3-编码"><a href="#3-3-编码" class="headerlink" title="3.3 编码"></a>3.3 编码</h3><p>在了解编码的概念之前，首先需要明白报文和实体的差别。</p>
<ul>
<li>报文：HTTP通信中的基本单位</li>
<li>实体：作为请求或响应的有效载荷数据被传输，包括实体首部和实体主体。</li>
</ul>
<p>HTTP报文的主体用于传输实体主体。</p>
<p>通常报文主体等于实体主体，只有传输中进行编码时，实体内容发生变化，与报文主体产生差异。</p>
<p>编码有以下几种：</p>
<ol>
<li>内容编码：应用在实体内容上，压缩传输</li>
<li>分块传输编码：将实体主体分成多个部分发往客户端</li>
</ol>
<h3 id="3-4-内容协商机制"><a href="#3-4-内容协商机制" class="headerlink" title="3.4 内容协商机制"></a>3.4 内容协商机制</h3><p>内容协商机制即客户端、服务器端就响应的资源内容进行交涉，提供给客户端最合适的资源。</p>
<ol>
<li>服务器驱动协商：由服务器端进行内容协商</li>
<li>客户端驱动协商：由客户端进行内容协商</li>
<li>透明协商：上述两种方法的一种结合体。</li>
</ol>
<h2 id="4-返回结果的HTTP状态码"><a href="#4-返回结果的HTTP状态码" class="headerlink" title="4. 返回结果的HTTP状态码"></a>4. 返回结果的HTTP状态码</h2><p>状态码描述返回的请求结果，由3位数字和原因短语组成。3位数字中的第一位指定响应类别，后两位无分类。</p>
<table>
<thead>
<tr>
<th align="center">类别</th>
<th align="center">原因短语</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1XX（信息性状态码）</td>
<td align="center">接收的请求正在处理</td>
</tr>
<tr>
<td align="center">2XX（成功状态码）</td>
<td align="center">请求正常处理完毕</td>
</tr>
<tr>
<td align="center">3XX（重定向状态码）</td>
<td align="center">需要进行附加操作以完成请求</td>
</tr>
<tr>
<td align="center">4XX（客户端错误状态码）</td>
<td align="center">服务器无法处理请求</td>
</tr>
<tr>
<td align="center">5XX（服务器错误状态码）</td>
<td align="center">服务器处理请求出错</td>
</tr>
</tbody></table>
<h3 id="4-1-2XX-成功"><a href="#4-1-2XX-成功" class="headerlink" title="4.1 2XX 成功"></a>4.1 2XX 成功</h3><ul>
<li>200 OK</li>
<li>204 No Content：成功处理。但返回的响应报文中不含实体主体</li>
<li>206 Parrtial Content：成功处理，返回指定范围的实体内容</li>
</ul>
<h3 id="4-2-3XX-重定向"><a href="#4-2-3XX-重定向" class="headerlink" title="4.2 3XX 重定向"></a>4.2 3XX 重定向</h3><ul>
<li>301 Moved Permanently：永久性重定向，更新URI</li>
<li>302 Found：临时重定向，资源临时更改URI，但不更新</li>
<li>303 See Other：明确指出使用GET方法获取资源</li>
<li>304 Not Modified：客户端发送附带条件的请求时，条件不满足（IF语句不满足）</li>
<li>307 Temporary Redirect：与302类似，但不会从POST变为GET</li>
</ul>
<h3 id="4-3-4XX-客户端错误"><a href="#4-3-4XX-客户端错误" class="headerlink" title="4.3 4XX 客户端错误"></a>4.3 4XX 客户端错误</h3><ul>
<li>400 Bad Request：请求报文存在语法错误</li>
<li>401 Unauthorized：第1次返回401，未认证；第2次返回401，认证失败</li>
<li>403 Forbidden：不允许访问该资源</li>
<li>404 Not Found：服务器上无此资源或拒绝说明理由</li>
</ul>
<h3 id="4-4-5XX服务器错误"><a href="#4-4-5XX服务器错误" class="headerlink" title="4.4 5XX服务器错误"></a>4.4 5XX服务器错误</h3><ul>
<li>500 Internal Server Error：服务器执行请求时发生错误</li>
<li>503 Service Unavailabel：服务器超负载或停机维护</li>
</ul>
<h2 id="5-与HTTP协作的Web服务器"><a href="#5-与HTTP协作的Web服务器" class="headerlink" title="5. 与HTTP协作的Web服务器"></a>5. 与HTTP协作的Web服务器</h2><p>一台服务器可以搭建多个Web站点，客户端访问这些站点时会映射到相同的IP地址，因此再发送HTTP请求时，需要指定主机名或域名的URI。</p>
<h3 id="5-1-通信数据转发应用程序"><a href="#5-1-通信数据转发应用程序" class="headerlink" title="5.1 通信数据转发应用程序"></a>5.1 通信数据转发应用程序</h3><p>HTTP通信时，除了客户端和服务器，还需要通信数据转发应用程序配合服务器工作。</p>
<ul>
<li>代理：转发功能，客户端和服务器通信间的中间人</li>
<li>网关：转发其他服务器通信数据的服务器，可以对客户端发送的请求进行处理。</li>
<li>隧道：在客户端和服务器间进行中转，保持双方通信连接</li>
</ul>
<h4 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h4><p>代理并不会改变请求URI</p>
<ol>
<li>缓存代理：转发响应时，代理将资源的副本保存在代理服务器上。代理再次接收到相同请求时，直接将缓存返回。</li>
<li>透明代理：不对报文做任何加工。</li>
</ol>
<h4 id="网关"><a href="#网关" class="headerlink" title="网关"></a>网关</h4><p>网关工作机制与代理类似，能使通信线路上的服务器提供非HTTP协议服务。提高通信的安全性。</p>
<h4 id="隧道"><a href="#隧道" class="headerlink" title="隧道"></a>隧道</h4><p>建立客户端与服务器的通信线路，使用SSL等加密手段，确保通信安全。</p>
<h3 id="5-2-缓存"><a href="#5-2-缓存" class="headerlink" title="5.2 缓存"></a>5.2 缓存</h3><p>利用缓存可以减少对服务器的访问，节省通信流量和时间。</p>
<p>缓存可以存在于缓存服务器和客户端浏览器中，当判定缓存过期后，会向源服务器确认资源的有效性。</p>
<h2 id="6-HTTPS"><a href="#6-HTTPS" class="headerlink" title="6. HTTPS"></a>6. HTTPS</h2><h3 id="6-1-HTTP缺点"><a href="#6-1-HTTP缺点" class="headerlink" title="6.1 HTTP缺点"></a>6.1 HTTP缺点</h3><ol>
<li>通信使用明文，解决方法：通信加密（HTTPS，基于SSL），内容加密</li>
<li>不验证通信方身份，解决方法：证书（基于SLL）</li>
<li>无法证明报文完整性，解决方法：摘要（基于SSL）</li>
</ol>
<h3 id="6-2-HTTPS介绍"><a href="#6-2-HTTPS介绍" class="headerlink" title="6.2 HTTPS介绍"></a>6.2 HTTPS介绍</h3><p>HTTPS即对HTTP添加加密、认证、完整性保护机制。添加的方法即对通信接口部分用SSL和TLS协议代替。HTTP先与SSL通信，再由SSL与TCP通信。</p>
<h4 id="SSL"><a href="#SSL" class="headerlink" title="#### SSL"></a>#### SSL</h4><p>SSL采用公开密钥加密方法。</p>
<p>共享（对称）密钥加密：加密和解密用同一个密钥，但密钥的发送无法确保安全。</p>
<p>公开（非对称）密钥加密：发送方用公开的密钥加密，接收方用私有密钥解密。</p>
<p>但是公开密钥加密与共享密钥加密相比，处理速度要慢。所以SSL利用两种方式的优势，采用混合加密方法。</p>
<p>但是在何时使用公开密钥，何时使用共享密钥呢？</p>
<p>大佬们想到了一个绝妙的主意：</p>
<ul>
<li>在交换密钥环节使用公开密钥加密</li>
<li>建立通信后，使用共享密钥加密。</li>
</ul>
<p>不过问题又来了，在隐私文件进行加密时，无法确定你拿到的密钥是目标发行的啊！若被攻击者替换了则也造成了泄密问题。</p>
<p>大佬们又想到了一个绝妙的主意。</p>
<h4 id="证书"><a href="#证书" class="headerlink" title="证书"></a>证书</h4><p>大佬们成立了一个公证机构叫数字证书认证机构（CA，Certificate Authority），公开密钥的发行者只要拿着自己的密钥到公证处认证，公证处检查合格后，就会给这个密钥签上自己的名字，客户端拿到这个签了名的公开密钥，可以进行验证。</p>
<p><strong>疑惑的一点是，客户端拿到的公开密钥是如何认证的呢？如何确保认证过程的安全性呢？</strong></p>
<p>答：客户端拿到公钥证书后，使用数字证书认证机构的公开密钥，向认证机构验证签名，而数字证书认证机构的密钥事先就植入到了浏览器里。</p>
<p>证书除了用来证明服务器的规范性外，还可确认服务器背后运营的企业是否真实存在。该类证书叫EV SSL（Extenden Validation SSL Certificate）证书。</p>
<p>除了上述的服务器证书、EV SSL证书，还存在一种叫<strong>客户端证书</strong>的东西，服务器用来证明正在通信的客户端。但是这种证书有效嘛？</p>
<p>客户端证书存在如下几个问题：</p>
<ul>
<li>客户端证书需要用户自行安装</li>
<li>每张证书需要支付费用</li>
</ul>
<p>因此，客户端证书只用于特殊的、重要的业务中。</p>
<p>上述所有证书的有效性都建立在一个前提下，也就是认证机构的绝对可信。但是认证机构就是绝对可信的嘛？大佬们已经用实践证明，Nope!!!</p>
<p>当黑客入侵了认证机构后，就可利用该机构发布伪造证书，而且无效证书的吊销、删除都需要一段时间生效。</p>
<h3 id="6-3-HTTPS安全通信机制"><a href="#6-3-HTTPS安全通信机制" class="headerlink" title="6.3 HTTPS安全通信机制"></a>6.3 HTTPS安全通信机制</h3><p>客户端与服务器进行通信时，先协商决定加密组件，之后服务器发送密钥给客户端，客户端通过生成随机数后，经公钥加密后发往服务器，服务器正确解密该报文后，则服务器与客户端建立通信。</p>
<h2 id="7-确认访问用户身份的认证"><a href="#7-确认访问用户身份的认证" class="headerlink" title="7. 确认访问用户身份的认证"></a>7. 确认访问用户身份的认证</h2><p>某些Web页面只想让特定的人浏览，为了达到这个目的，就需要对访问者进行认证，这个时候大家可以思考一下，在进入自己的空间时，经过了哪些认证呢？</p>
<h3 id="7-1-什么是认证？"><a href="#7-1-什么是认证？" class="headerlink" title="7.1 什么是认证？"></a>7.1 什么是认证？</h3><p>为了达到确认使用者身份的问题，进行认证的信息应该是登录者本人才知道的信息，比如密码、生物认证等，但是如果你把密码泄露给别人，那也就都没辙啦！</p>
<p>在HTTP/1.1中使用的认证方式包括以下几种</p>
<ul>
<li>BASIC认证（基本认证）</li>
<li>DIGEST认证（摘要认证）</li>
<li>SSL客户端认证</li>
<li>FormBase认证（基于表单认证）</li>
</ul>
<p>下面就挨个了解一下吧！</p>
<h3 id="7-2-BASIC认证"><a href="#7-2-BASIC认证" class="headerlink" title="7.2 BASIC认证"></a>7.2 BASIC认证</h3><p>BASIC认证在HTTP/1.0就定义了这种认证方式（大概在92年，比我大多了，哭了）。但是哦！现在还有一部分网站会使用这种认证方式！真的可以说经久不衰了！</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">客户端-&gt;服务器: 发送请求</span><br><span class="line">服务器-&gt;客户端: 返回状态码401告知客户端需要进行认证</span><br><span class="line">客户端-&gt;服务器: 用户ID和密码以Base64方式编码后发送</span><br><span class="line">服务器-&gt;客户端: 认证成功返回状态码200，失败返回401</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>可以看到，在BASIC认证方式中，并没有对账号、密码进行加密，只是进行了一次编码，因此BASIC认证在HTTP这种非加密通信线路上进行BASIC认证时，相当于裸奔。</p>
<p>另外，使用BASIC认证时，一般的浏览器<strong>无法实现注销操作</strong>。这是啥意思，姐妹们想一下，你登陆了还轻易无法退出？？？离谱离谱，告辞！</p>
<h3 id="7-3-DIGEST-认证"><a href="#7-3-DIGEST-认证" class="headerlink" title="7.3 DIGEST 认证"></a>7.3 DIGEST 认证</h3><p>DIGEST认证方式是在HTTP/1.1起开始增加的，其目的主要是为了弥补BASIC认证存在的弱点。因此其认证方式也采用相同的<strong>质询/响应（challenge/response）</strong>的方式，但是不会像BASIC那样把明文密码发送过去。</p>
<p>那么它是怎样实现的呢？</p>
<p>服务器在收到客户端的访问请求时，会向客户端发送一个<strong>随机生成的质询码</strong>，并告知客户端需要认证，客户端由质询码计算出<strong>响应码</strong>，发送到服务器。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">客户端-&gt;服务器: 发送请求</span><br><span class="line">服务器-&gt;客户端: 返回状态码401和随机生成的质询码告知客户端需要进行认证</span><br><span class="line">客户端-&gt;服务器: 发送摘要和由质询码计算出的响应码</span><br><span class="line">服务器-&gt;客户端: 认证成功返回状态码200，失败返回401</span><br></pre></td></tr></table></figure>

<h3 id="7-4-SSL客户端认证"><a href="#7-4-SSL客户端认证" class="headerlink" title="7.4 SSL客户端认证"></a>7.4 SSL客户端认证</h3><p>SSL客户端认证就牛批了嗷~如果说BASIC和DIGEST只能验证账号、密码的话，那么只要密码泄露了，账号就不保了，但是SSL客户端认证可以解决这种问题。这是怎么做到的呢？？？？</p>
<p>SSL客户端在进行认证时，通过证书完成，<strong>只有获得证书的客户端</strong>，才能与服务器建立通信。</p>
<p>由于只依靠证书进行认证还是有点单薄，因此在多数情况下会采用一种<strong>双因素认证</strong>方式。所谓的双因素其实很好理解，即客户端除了要提供密码这一认证因素外，还要提供其他认证因素，相当于双重保险。</p>
<h3 id="7-5-基于表单认证"><a href="#7-5-基于表单认证" class="headerlink" title="7.5 基于表单认证"></a>7.5 基于表单认证</h3><p>首先需要明确的一点是基于表单的认证方法<strong>并不是在HTTP协议中定义</strong>的，而是由客户端向服务器上的Web应用程序发送登陆信息，按登陆信息进行验证。</p>
<p>由于不依赖于HTTP协议，因此Web应用程序可以各自实现基于表单的认证方式。安全性则有Web应用程序的设计者决定。</p>
<h4 id="7-5-1-Session管理及Cookie应用"><a href="#7-5-1-Session管理及Cookie应用" class="headerlink" title="7.5.1 Session管理及Cookie应用"></a>7.5.1 Session管理及Cookie应用</h4><p>表单的认证方法并不是在HTTP协议中定义的，但是！客户端与服务器间的通信还是要通过HTTP。</p>
<p>我们在上面已经学过了，HTTP是无状态协议**，即就算你之前已经登陆过一个网站，但这种登陆状态无法通过协议层保存下来。</p>
<p>为了解决这个问题，大佬们使用Cookie来管理Session，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">客户端-&gt;服务器: 发送已登陆信息</span><br><span class="line">服务器-&gt;客户端: 向用户发放Session ID，记录认证状态</span><br><span class="line">客户端-&gt;服务器: 发送包含Session ID的Cookie</span><br></pre></td></tr></table></figure>

<p>由于认证依赖于Session ID,所以要确保Session ID的安全性。</p>
]]></content>
      <tags>
        <tag>home</tag>
      </tags>
  </entry>
</search>
